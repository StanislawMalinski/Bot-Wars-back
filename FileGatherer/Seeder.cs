using System.Text;

namespace FileGatherer;

public class Seeder
{
    private readonly GathererService _gatherer;

    private readonly string black_jack_cpp =
        "#include <iostream>\r\n#include <vector>\r\n#include <ctime>\r\n#include <cstdlib>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct Card {\r\n    string suit;\r\n    string faceValue;\r\n};\r\n\r\nclass Deck {\r\nprivate:\r\n    vector<Card> cards;\r\n\r\npublic:\r\n    Deck() {\r\n        string suits[] = {\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"};\r\n        string faceValues[] = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"};\r\n\r\n        for (const auto &suit : suits) {\r\n            for (const auto &faceValue : faceValues) {\r\n                cards.push_back({suit, faceValue});\r\n            }\r\n        }\r\n    }\r\n\r\n    void shuffle() {\r\n        srand(time(nullptr));\r\n        for (int i = 0; i < cards.size(); ++i) {\r\n            int randomIndex = rand() % cards.size();\r\n            swap(cards[i], cards[randomIndex]);\r\n        }\r\n    }\r\n\r\n    void displayDeck() {\r\n        for (const auto &card : cards) {\r\n            cout << card.faceValue << \" of \" << card.suit << endl;\r\n        }\r\n    }\r\n\r\n    Card drawCard() {\r\n        if (cards.empty()) {\r\n            string suits[] = {\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"};\r\n            string faceValues[] = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"};\r\n\r\n            for (const auto &suit : suits) {\r\n                for (const auto &faceValue : faceValues) {\r\n                    cards.push_back({suit, faceValue});\r\n                }\r\n            }\r\n            shuffle();\r\n        }\r\n\r\n        Card drawnCard = cards.back();\r\n        cards.pop_back();\r\n        return drawnCard;\r\n    }\r\n};\r\n\r\n//-------------------------------------------------\r\n\r\nint countPoints(const vector<Card>& hand) {\r\n    int points = 0;\r\n    int numAces = 0;\r\n\r\n    for (const auto& card : hand) {\r\n        if (card.faceValue == \"Jack\" || card.faceValue == \"Queen\" || card.faceValue == \"King\") {\r\n            points += 10;\r\n        } else if (card.faceValue == \"Ace\") {\r\n            numAces++;\r\n            points += 11;\r\n        } else {\r\n            points += stoi(card.faceValue);\r\n        }\r\n    }\r\n\r\n    while (points > 21 && numAces > 0) {\r\n        points -= 10;\r\n        numAces--;\r\n    }\r\n    return points;\r\n}\r\n\r\n//-------------------------------------------------\r\n\r\nint dealerTurn(Deck& deck, std::vector<Card>& dealerHand) {\r\n    int sum = 0;\r\n    for (const auto& card : dealerHand) {\r\n        if (card.faceValue == \"Jack\" || card.faceValue == \"Queen\" || card.faceValue == \"King\") {\r\n            sum += 10;\r\n        } else if (card.faceValue == \"Ace\") {\r\n            sum += 11;\r\n        } else {\r\n            sum += std::stoi(card.faceValue);\r\n        }\r\n    }\r\n\r\n    while (sum <= 17) {\r\n        Card newCard = deck.drawCard();\r\n        dealerHand.push_back(newCard);\r\n        sum = countPoints(dealerHand);\r\n    }\r\n    return sum;\r\n}\r\nvoid giveBotInfo(int botId, std::vector<Card>& playerHand, std::vector<Card>& dealerHand){\r\n    \r\n    cout << botId<< endl;\r\n    for (const auto& card : playerHand) {\r\n        cout << card.faceValue.c_str() << \"_\"<<card.suit.c_str() << \" \";\r\n    }\r\n    cout << \"d: \";\r\n    for (const auto& card : dealerHand) {\r\n        cout << card.faceValue.c_str() << \"_\"<<card.suit.c_str()<<\" \";\r\n    }\r\n    cout << endl;\r\n}\r\n\r\n//-------------------------------------------------\r\nDeck deck;\r\ndouble countpoints(std::vector<int>& bot, std::vector<Card>& dealerHand){ //{0 handValue, 1 splitValue, 2 doubledBet, 3 surrendered, 4 insurance};\r\n    int dealer = countPoints(dealerHand);\r\n    \r\n    if (bot[3]) // jeśli się podda\r\n        return -0.5;\r\n        \r\n    if (bot[4])\r\n        if(dealerHand.size() == 2 && dealer == 21) // ubezpieczenie\r\n            return 0;\r\n        else\r\n            return -1.5;\r\n            \r\n    if (bot[1] != 0){ // jeśli jest 2 ręka\r\n        double sum=0;\r\n        if (bot[0] < 22)\r\n            if (bot[0] > dealer || dealer > 21)\r\n                sum += 1;\r\n            else sum -=1;\r\n        else sum -=1;\r\n            \r\n\r\n        if (bot[1] < 22)\r\n            if (bot[1] > dealer || dealer > 21)\r\n                sum += 1;\r\n            else sum -=1;\r\n        else sum -=1;\r\n        return sum;\r\n    }\r\n\r\n    if ((bot[0] > dealer && bot[0] < 22) || (bot[0] < 22 && dealer > 21))\r\n        if (bot[2])\r\n            return 2;\r\n        else return 1;\r\n    else\r\n        if (bot[2])\r\n            return -2;\r\n        else return -1;\r\n}\r\n\r\nvector<int> servebot(int botId, std::vector<Card>& playerHand, std::vector<Card>& dealerHand){\r\n    if(playerHand.size()==0){\r\n        playerHand.push_back(deck.drawCard());\r\n        playerHand.push_back(deck.drawCard());\r\n    }\r\n\r\n    int handValue = countPoints(playerHand);\r\n    int splitValue = 0;\r\n    int doubledBet = 0;\r\n    int surrendered = 0;\r\n    int insurance = 0;\r\n\r\n    if(countPoints(playerHand) == 21)\r\n        return {handValue, splitValue, doubledBet, surrendered, insurance};\r\n\r\n    giveBotInfo(botId, playerHand, dealerHand);\r\n    string response;\r\n    cin >> response;\r\n\r\n    if (response == \"hit\") {\r\n        while(response == \"hit\" && countPoints(playerHand) < 21){\r\n            playerHand.push_back(deck.drawCard());\r\n            giveBotInfo(botId, playerHand, dealerHand);\r\n            cin >> response;\r\n        }\r\n        handValue = countPoints(playerHand);\r\n    } else if (response == \"double\") {\r\n        if(countPoints(playerHand) == 9 ||countPoints(playerHand) == 10 || countPoints(playerHand) == 11){\r\n            playerHand.push_back(deck.drawCard());\r\n            doubledBet = 1;\r\n        }\r\n    } else if (response == \"split\") {\r\n        if (playerHand.size() == 2 && playerHand[0].faceValue == playerHand[1].faceValue) {\r\n            std::vector<Card> splitHand1;\r\n            std::vector<Card> splitHand2;\r\n            splitHand1.push_back(playerHand[0]);\r\n            splitHand2.push_back(playerHand[1]);\r\n            splitHand1.push_back(deck.drawCard());\r\n            splitHand2.push_back(deck.drawCard());\r\n\r\n            giveBotInfo(botId, splitHand1, dealerHand);\r\n            cin >> response;\r\n            while(response == \"hit\"){\r\n                splitHand1.push_back(deck.drawCard());\r\n                giveBotInfo(botId, splitHand1, dealerHand);\r\n                string response;\r\n                cin >> response;\r\n            }\r\n\r\n            giveBotInfo(botId, splitHand2, dealerHand);\r\n            cin >> response;\r\n            while(response == \"hit\"){\r\n                splitHand2.push_back(deck.drawCard());\r\n                giveBotInfo(botId, splitHand2, dealerHand);\r\n                string response;\r\n                cin >> response;\r\n            }\r\n\r\n            handValue = countPoints(splitHand1);\r\n            splitValue = countPoints(splitHand2);\r\n        }\r\n    } else if (response == \"surrender\") {\r\n        surrendered = 1;\r\n    }\r\n      else if (response == \"insurance\") {\r\n        if(countPoints(dealerHand) == 10 || countPoints(dealerHand) == 11)\r\n            insurance = 1;\r\n    }\r\n    return {handValue, splitValue, doubledBet, surrendered, insurance};\r\n}\r\n\r\nint main() {\r\n\r\n    deck.shuffle();\r\n    double bot0money=10;\r\n    double bot1money=10;\r\n    std::vector<Card> dealerHand;\r\n    int turn = 0;\r\n\r\n    vector<int> bot0;\r\n    vector<int> bot1;\r\n    while((turn < 100 || bot0money != bot1money) && turn < 1000){\r\n        turn++;\r\n        dealerHand.push_back(deck.drawCard());\r\n\r\n        vector<Card> playerHand1;\r\n        vector<Card> playerHand2;\r\n\r\n        bot0 = servebot(0, playerHand1, dealerHand);\r\n        bot1 = servebot(1, playerHand2, dealerHand);\r\n\r\n        dealerTurn(deck, dealerHand);\r\n\r\n        bot0money += countpoints(bot0, dealerHand);\r\n        bot1money += countpoints(bot1, dealerHand);\r\n\r\n        if(bot0money < 1 || bot1money < 1)\r\n            break;\r\n        dealerHand = vector<Card>();\r\n    }\r\n\r\n    \r\n    cout << -1 << endl;\r\n    if(bot0money > bot1money)\r\n        cout << 0 << endl;\r\n    else\r\n        cout << 1 << endl;\r\n\r\n    return 0;\r\n}\r\n";

    private readonly string bot_zero_2_py =
        "import copy\r\n\r\nclass Card:\r\n    def __init__(self, suit, value):\r\n        self.suit = suit\r\n        self.value = value\r\n\r\n    def __repr__(self):\r\n        return f\"{self.value} of {self.suit}\"\r\n    \r\n    def __str__(self):\r\n        return f\"{self.value} of {self.suit}\"\r\n\r\n\r\ndef parse_cards(data):\r\n    hand_cards = []\r\n    cards = data.split('; Table: ')\r\n    #print(cards)\r\n    hand = cards[0].split(';')\r\n    #print(hand)\r\n    for card in hand:\r\n        val = int(card.split(' ')[0])\r\n        suit = card.split(' ')[2]\r\n        hand_cards.append(Card(suit, val))\r\n        #print(f'{val} of {suit}')\r\n    table = [card.strip() for card in cards[1].strip().split(';') if card.strip()]\r\n    table_cards = []\r\n    #print(table)\r\n    for card in table:\r\n        val = int(card.split(' ')[0])\r\n        suit = card.split(' ')[2]\r\n        table_cards.append(Card(suit, val))\r\n    return hand_cards, table_cards\r\n\r\ndef count_points(hand):\r\n    if (len(hand) != 9):\r\n        raise ValueError(\"Wrong number of cards in hand!\")\r\n    points = 0\r\n    distinct_values = set()\r\n    distinct_colors = set()\r\n    color_counts = {}\r\n    value_counts = {}\r\n\r\n    for card in hand:\r\n        distinct_values.add(card.value)\r\n        distinct_colors.add(card.suit)\r\n        color_counts[card.suit] = color_counts.get(card.suit, 0) + 1\r\n        value_counts[card.value] = value_counts.get(card.value, 0) + 1\r\n        \r\n    for card in hand:\r\n        if (color_counts[card.suit] == 5 and value_counts[card.value] == 5):\r\n            return 0\r\n\r\n    for color in distinct_colors:\r\n        if color_counts[color] > 4:\r\n            distinct_values = set()\r\n            value_counts = {}\r\n            for card in hand:\r\n                if (card.suit != color):\r\n                    distinct_values.add(card.value)\r\n                    value_counts[card.value] = value_counts.get(card.value, 0) + 1\r\n            \r\n    for value in distinct_values:\r\n        if value_counts[value] < 5:\r\n            points += int(value)\r\n\r\n    return points\r\n\r\ndef exchange_card(player_hand, table_cards, hand_index, table_index):\r\n    if hand_index < 0 or hand_index >= len(player_hand):\r\n        print(\"Wrong card index.\")\r\n        return\r\n    if table_index < 0 or table_index >= len(table_cards):\r\n        print(\"Wrong table index.\")\r\n        return\r\n    hand = player_hand.copy()\r\n    hand[hand_index] = table_cards[table_index]\r\n    return hand\r\n\r\ndef play():\r\n    while(True):\r\n        #print(\"Wczytuje\")\r\n        status = input()\r\n        hand, table = parse_cards(status)\r\n        #print(\"Wczytane\")\r\n        points = count_points(hand)\r\n        response = \"fold\"\r\n        #print(\"Rozpoczynam liczenie\")\r\n        for i in range (9):\r\n            for j in range (5):\r\n                fake_hand = exchange_card(hand, table, i, j)\r\n                fake_points = count_points(fake_hand)\r\n                if (fake_points >= points):\r\n                    response = str(i) + \" \" + str(j)\r\n                    points = fake_points\r\n        \r\n        #print(\"Koncze liczenie\")\r\n        print(response)\r\nplay()";

    private readonly string bot_zero_3_py =
        "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <string>\r\n\r\nint main() {\r\n    std::string tekst;\r\n\r\n    while(true){\r\n        std::getline(std::cin, tekst);\r\n\r\n        std::srand(std::time(nullptr));\r\n\r\n        int losowa1 = std::rand() % 9;\r\n        int losowa2 = std::rand() % 5;\r\n\r\n        std::cout << losowa1 << \" \" << losowa2 << std::endl;\r\n    }\r\n    return 0;\r\n}\r\n";

    private readonly string bot_zero_py =
        "import copy\r\n\r\nclass Card:\r\n    def __init__(self, suit, value):\r\n        self.suit = suit\r\n        self.value = value\r\n\r\n    def __repr__(self):\r\n        return f\"{self.value} of {self.suit}\"\r\n    \r\n    def __str__(self):\r\n        return f\"{self.value} of {self.suit}\"\r\n\r\n\r\ndef parse_cards(data):\r\n    hand_cards = []\r\n    cards = data.split('; Table: ')\r\n    #print(cards)\r\n    hand = cards[0].split(';')\r\n    #print(hand)\r\n    for card in hand:\r\n        val = int(card.split(' ')[0])\r\n        suit = card.split(' ')[2]\r\n        hand_cards.append(Card(suit, val))\r\n        #print(f'{val} of {suit}')\r\n    table = [card.strip() for card in cards[1].strip().split(';') if card.strip()]\r\n    table_cards = []\r\n    #print(table)\r\n    for card in table:\r\n        val = int(card.split(' ')[0])\r\n        suit = card.split(' ')[2]\r\n        table_cards.append(Card(suit, val))\r\n    return hand_cards, table_cards\r\n\r\ndef count_points(hand):\r\n    if (len(hand) != 9):\r\n        raise ValueError(\"Wrong number of cards in hand!\")\r\n    points = 0\r\n    distinct_values = set()\r\n    distinct_colors = set()\r\n    color_counts = {}\r\n    value_counts = {}\r\n\r\n    for card in hand:\r\n        distinct_values.add(card.value)\r\n        distinct_colors.add(card.suit)\r\n        color_counts[card.suit] = color_counts.get(card.suit, 0) + 1\r\n        value_counts[card.value] = value_counts.get(card.value, 0) + 1\r\n        \r\n    for card in hand:\r\n        if (color_counts[card.suit] == 5 and value_counts[card.value] == 5):\r\n            return 0\r\n\r\n    for color in distinct_colors:\r\n        if color_counts[color] > 4:\r\n            distinct_values = set()\r\n            value_counts = {}\r\n            for card in hand:\r\n                if (card.suit != color):\r\n                    distinct_values.add(card.value)\r\n                    value_counts[card.value] = value_counts.get(card.value, 0) + 1\r\n            \r\n    for value in distinct_values:\r\n        if value_counts[value] < 5:\r\n            points += int(value)\r\n\r\n    return points\r\n\r\ndef exchange_card(player_hand, table_cards, hand_index, table_index):\r\n    if hand_index < 0 or hand_index >= len(player_hand):\r\n        print(\"Wrong card index.\")\r\n        return\r\n    if table_index < 0 or table_index >= len(table_cards):\r\n        print(\"Wrong table index.\")\r\n        return\r\n    hand = player_hand.copy()\r\n    hand[hand_index] = table_cards[table_index]\r\n    return hand\r\n\r\ndef play():\r\n    while(True):\r\n        #print(\"Wczytuje\")\r\n        status = input()\r\n        hand, table = parse_cards(status)\r\n        #print(\"Wczytane\")\r\n        points = count_points(hand)\r\n        response = \"fold\"\r\n        #print(\"Rozpoczynam liczenie\")\r\n        for i in range (9):\r\n            for j in range (5):\r\n                fake_hand = exchange_card(hand, table, i, j)\r\n                fake_points = count_points(fake_hand)\r\n                if (fake_points <= points):\r\n                    response = str(i) + \" \" + str(j)\r\n                    points = fake_points\r\n        \r\n        #print(\"Koncze liczenie\")\r\n        print(response)\r\nplay()";

    private readonly string bot1Bj_cpp =
        "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\n\r\nstruct Card {\r\n    string suit;\r\n    string faceValue;\r\n};\r\n\r\nbool isValidCard(const string& faceValue, const string& suit) {\r\n    string acceptedFaceValues[] = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"};\r\n    string acceptedSuits[] = {\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"};\r\n\r\n    bool isValidFaceValue = false;\r\n    for (const string& acceptedValue : acceptedFaceValues) {\r\n        if (faceValue == acceptedValue) {\r\n            isValidFaceValue = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    bool isValidSuit = false;\r\n    for (const string& acceptedSuit : acceptedSuits) {\r\n        if (suit == acceptedSuit) {\r\n            isValidSuit = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return isValidFaceValue && isValidSuit;\r\n}\r\n\r\nint main() {\r\n    string input;\r\n    \r\n    vector<long> cossr(1000000);\r\n    cossr[12] = 232;\r\n    vector<Card> playerHand;\r\n    vector<Card> dealerHand;\r\n\r\n    while (true) {\r\n        getline(cin, input);\r\n        playerHand = vector<Card>();\r\n        dealerHand = vector<Card>();\r\n        size_t dealerIndex = input.find(\"d:\");\r\n        string playerData = input.substr(0, dealerIndex);\r\n        string dealerData = input.substr(dealerIndex + 2);\r\n\r\n        size_t pos = 0;\r\n        string delimiter = \" \";\r\n        while ((pos = playerData.find(delimiter)) != string::npos) {\r\n            string cardStr = playerData.substr(0, pos);\r\n            size_t underscorePos = cardStr.find(\"_\");\r\n            string faceValue = cardStr.substr(0, underscorePos);\r\n            string suit = cardStr.substr(underscorePos + 1);\r\n            if (isValidCard(faceValue, suit)) {\r\n                playerHand.push_back({suit, faceValue});\r\n            }\r\n            playerData.erase(0, pos + delimiter.length());\r\n        }\r\n\r\n        pos = 0;\r\n        while ((pos = dealerData.find(delimiter)) != string::npos) {\r\n            string cardStr = dealerData.substr(0, pos);\r\n            size_t underscorePos = cardStr.find(\"_\");\r\n            string faceValue = cardStr.substr(0, underscorePos);\r\n            string suit = cardStr.substr(underscorePos + 1);\r\n            if (isValidCard(faceValue, suit)) {\r\n                dealerHand.push_back({suit, faceValue});\r\n            }\r\n            dealerData.erase(0, pos + delimiter.length());\r\n        }\r\n\r\n        size_t underscorePos = dealerData.find(\"_\");\r\n        string faceValue = dealerData.substr(0, underscorePos);\r\n        string suit = dealerData.substr(underscorePos + 1);\r\n        if (isValidCard(faceValue, suit)) {\r\n            dealerHand.push_back({suit, faceValue});\r\n        }\r\n        cout << \"hit\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}";

    private readonly string bot2Bj_cpp =
        "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\n\r\nstruct Card {\r\n    string suit;\r\n    string faceValue;\r\n};\r\n\r\nint countPoints(const vector<Card>& hand) {\r\n    int points = 0;\r\n    int numAces = 0;\r\n\r\n    for (const auto& card : hand) {\r\n        if (card.faceValue == \"Jack\" || card.faceValue == \"Queen\" || card.faceValue == \"King\") {\r\n            points += 10;\r\n        } else if (card.faceValue == \"Ace\") {\r\n            numAces++;\r\n        } else {\r\n            try {\r\n                int value = stoi(card.faceValue);\r\n                points += value;\r\n            } catch (const invalid_argument& e) {\r\n                cerr << \"Nieprawidłowa wartość karty: \" << card.faceValue << endl;\\\r\n            }\r\n        }\r\n    }\r\n    while (points > 21 && numAces > 0) {\r\n        points -= 10;\r\n        numAces--;\r\n    }\r\n    return points;\r\n}\r\n\r\nbool isValidCard(const string& faceValue, const string& suit) {\r\n    string acceptedFaceValues[] = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"};\r\n    string acceptedSuits[] = {\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"};\r\n\r\n    bool isValidFaceValue = false;\r\n    for (const string& acceptedValue : acceptedFaceValues) {\r\n        if (faceValue == acceptedValue) {\r\n            isValidFaceValue = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    bool isValidSuit = false;\r\n    for (const string& acceptedSuit : acceptedSuits) {\r\n        if (suit == acceptedSuit) {\r\n            isValidSuit = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return isValidFaceValue && isValidSuit;\r\n}\r\n\r\nint main() {\r\n    string input;\r\n\r\n    vector<Card> playerHand;\r\n    vector<Card> dealerHand;\r\n\r\n    while (true) {\r\n        getline(cin, input);\r\n        playerHand = vector<Card>();\r\n        dealerHand = vector<Card>();\r\n        size_t dealerIndex = input.find(\"d:\");\r\n        string playerData = input.substr(0, dealerIndex);\r\n        string dealerData = input.substr(dealerIndex + 2);\r\n\r\n        size_t pos = 0;\r\n        string delimiter = \" \";\r\n        while ((pos = playerData.find(delimiter)) != string::npos) {\r\n            string cardStr = playerData.substr(0, pos);\r\n            size_t underscorePos = cardStr.find(\"_\");\r\n            string faceValue = cardStr.substr(0, underscorePos);\r\n            string suit = cardStr.substr(underscorePos + 1);\r\n            if (isValidCard(faceValue, suit)) {\r\n                playerHand.push_back({suit, faceValue});\r\n            }\r\n            playerData.erase(0, pos + delimiter.length());\r\n        }\r\n\r\n        pos = 0;\r\n        while ((pos = dealerData.find(delimiter)) != string::npos) {\r\n            string cardStr = dealerData.substr(0, pos);\r\n            size_t underscorePos = cardStr.find(\"_\");\r\n            string faceValue = cardStr.substr(0, underscorePos);\r\n            string suit = cardStr.substr(underscorePos + 1);\r\n            if (isValidCard(faceValue, suit)) {\r\n                dealerHand.push_back({suit, faceValue});\r\n            }\r\n            dealerData.erase(0, pos + delimiter.length());\r\n        }\r\n\r\n        size_t underscorePos = dealerData.find(\"_\");\r\n        string faceValue = dealerData.substr(0, underscorePos);\r\n        string suit = dealerData.substr(underscorePos + 1);\r\n        if (isValidCard(faceValue, suit)) {\r\n            dealerHand.push_back({suit, faceValue});\r\n        }\r\n        if (countPoints(playerHand)>16)\r\n            cout << \"stand\" << endl;\r\n        else\r\n            cout << \"hit\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n";

    private readonly string bot3Bj_cpp =
        "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\n\r\nstruct Card {\r\n    string suit;\r\n    string faceValue;\r\n};\r\n\r\nint countPoints(const vector<Card>& hand) {\r\n    int points = 0;\r\n    int numAces = 0;\r\n\r\n    for (const auto& card : hand) {\r\n        if (card.faceValue == \"Jack\" || card.faceValue == \"Queen\" || card.faceValue == \"King\") {\r\n            points += 10;\r\n        } else if (card.faceValue == \"Ace\") {\r\n            numAces++;\r\n            points += 11;\r\n        } else {\r\n            try {\r\n                int value = stoi(card.faceValue);\r\n                points += value;\r\n            } catch (const invalid_argument& e) {\r\n                cerr << \"Nieprawidłowa wartość karty: \" << card.faceValue << endl;\\\r\n            }\r\n        }\r\n    }\r\n    while (points > 21 && numAces > 0) {\r\n        points -= 10;\r\n        numAces--;\r\n    }\r\n    return points;\r\n}\r\n\r\nbool isValidCard(const string& faceValue, const string& suit) {\r\n    string acceptedFaceValues[] = {\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"Jack\", \"Queen\", \"King\", \"Ace\"};\r\n    string acceptedSuits[] = {\"Hearts\", \"Diamonds\", \"Clubs\", \"Spades\"};\r\n\r\n    bool isValidFaceValue = false;\r\n    for (const string& acceptedValue : acceptedFaceValues) {\r\n        if (faceValue == acceptedValue) {\r\n            isValidFaceValue = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    bool isValidSuit = false;\r\n    for (const string& acceptedSuit : acceptedSuits) {\r\n        if (suit == acceptedSuit) {\r\n            isValidSuit = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return isValidFaceValue && isValidSuit;\r\n}\r\n\r\nint main() {\r\n    string input;\r\n\r\n    vector<Card> playerHand;\r\n    vector<Card> dealerHand;\r\n\r\n    while (true) {\r\n        getline(cin, input);\r\n        playerHand = vector<Card>();\r\n        dealerHand = vector<Card>();\r\n        size_t dealerIndex = input.find(\"d:\");\r\n        string playerData = input.substr(0, dealerIndex);\r\n        string dealerData = input.substr(dealerIndex + 2);\r\n\r\n        size_t pos = 0;\r\n        string delimiter = \" \";\r\n        while ((pos = playerData.find(delimiter)) != string::npos) {\r\n            string cardStr = playerData.substr(0, pos);\r\n            size_t underscorePos = cardStr.find(\"_\");\r\n            string faceValue = cardStr.substr(0, underscorePos);\r\n            string suit = cardStr.substr(underscorePos + 1);\r\n            if (isValidCard(faceValue, suit)) {\r\n                playerHand.push_back({suit, faceValue});\r\n            }\r\n            playerData.erase(0, pos + delimiter.length());\r\n        }\r\n\r\n        pos = 0;\r\n        while ((pos = dealerData.find(delimiter)) != string::npos) {\r\n            string cardStr = dealerData.substr(0, pos);\r\n            size_t underscorePos = cardStr.find(\"_\");\r\n            string faceValue = cardStr.substr(0, underscorePos);\r\n            string suit = cardStr.substr(underscorePos + 1);\r\n            if (isValidCard(faceValue, suit)) {\r\n                dealerHand.push_back({suit, faceValue});\r\n            }\r\n            dealerData.erase(0, pos + delimiter.length());\r\n        }\r\n\r\n        size_t underscorePos = dealerData.find(\"_\");\r\n        string faceValue = dealerData.substr(0, underscorePos);\r\n        string suit = dealerData.substr(underscorePos + 1);\r\n        if (isValidCard(faceValue, suit)) {\r\n            dealerHand.push_back({suit, faceValue});\r\n        }\r\n        if (countPoints(playerHand)>18 && playerHand.size()==2)\r\n            cout<<\"double\" << endl;\r\n        else\r\n        {\r\n            if(countPoints(dealerHand) == 11)\r\n            cout<<\"insurance\" << endl;\r\n                \r\n            else{\r\n                if(countPoints(playerHand)<18)\r\n                cout<<\"hit\" << endl;\r\n                else cout<<\"stand\" << endl;\r\n                }\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}";

    private readonly string javabot =
        "import java.util.Scanner;\nimport java.util.Random;\n\npublic class bot_zero_5 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Random rand = new Random();\n        while (true) {\n            String text1 = scanner.nextLine();\n            int handCard = rand.nextInt(9);\n            int tableCard = rand.nextInt(5);\n            int fold = rand.nextInt(10);\n            if (fold == 0)\n                System.out.println(\"fold\");\n            else\n                System.out.println(handCard + \" \" + tableCard);\n\n        }\n    }\n}";

    private readonly string chess_game_cpp =
        "\n\n#define BOARD_SIZE 8\n#define BOX_WIDTH 10\n#define DOWN 3\n#define RIGHT 10\n#define TO_DOWN std::string(DOWN, '\\n')\n#define TO_RIGHT std::string(RIGHT, ' ')\n#define CLEAR_LINE std::string(100, ' ')\n#define MOVES_PER_LINE 5\n\n#define AGAINST_BOT true\t\t\t// if true then it's ? vs bot, if false then it's player vs player\n#define TWO_BOTS true\t\t\t\t// assuming AGAINST_BOT is true, if true then it's bot vs bot, if false then it's player vs bot\n#define BOT_IS_WHITE false\t\t\t// assuming AGAINST_BOT is true and TWO_BOTS is false, if true then the bot is team white, black otherwise\n#define WHITE_BOT_RANDOM true\t\t// if true the white bot returns random moves, if false the white bot returns smart moves generated by minimax algorithm\n#define BLACK_BOT_RANDOM false\t\t// if true the black bot returns random moves, if false the black bot returns smart moves generated by minimax algorithm\n#define WHITE_BOT_DIFFICULTY 1\t\t// the tree depth of decision tree of the bot, which is also correlated to the bot's difficulty (aka chess IQ)\n#define BLACK_BOT_DIFFICULTY 1\t\t// 1: easy, 2: medium, 3: hard\n\n// types of chess pieces\ntypedef enum {\n\tB_KING = -6, B_QUEEN, B_BISHOP, B_KNIGHT, B_ROOK, B_PAWN, EMPTY,\n\tW_KING, W_QUEEN, W_BISHOP, W_KNIGHT, W_ROOK, W_PAWN\n} ChessPieces;\n\n// types of player moves\ntypedef enum {\n\tNORMAL, CASTLING, PROMOTION, EN_PASSANT\n} Moves;\n\n// possible options on how the game can end\ntypedef enum {\n\tCHECKMATE, FIFTY_MOVES, THREEFOLD_REP, QUIT\n} Endgame;\n\n// starting position of the board\nconst char STARTING_BOARD[BOARD_SIZE][BOARD_SIZE] = {{B_ROOK, B_KNIGHT, B_BISHOP, B_QUEEN, B_KING, B_BISHOP, B_KNIGHT, B_ROOK},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{W_ROOK, W_KNIGHT, W_BISHOP, W_QUEEN, W_KING, W_BISHOP, W_KNIGHT, W_ROOK}};\n\nclass Player;\nclass PathNode;\nclass Bot;\nclass Chess;\n\n#include <string>\n#include <forward_list>\n#include <vector>\n#include <map>\n#include <iostream>\n#include <algorithm>\n\n\n\n\n// player class declaration\nclass Player {\nprotected:\n\tstd::string name;\t\t\t// name of the player\n\tunsigned short score = 0;\t// score of the player\n\tbool castling = true;\t\t// if true the player can castle, if false the player cannot castle anymore during the game\npublic:\n\tPlayer(const std::string &name) noexcept;\n\tstd::string GetName() const noexcept;\n\tunsigned short GetScore() const noexcept;\n\tbool GetCastling() const noexcept;\n\tvoid SetCastling(const bool &castling) noexcept;\n\tvoid IncreaseScore(const unsigned short &inc) noexcept;\n\tvoid Reset() noexcept;\n\tbool operator== (const Player &p) const noexcept;\n};\n\n// path node class declaration\nclass PathNode {\nprivate:\n\tstd::map<std::string, PathNode> child_node_list;\t// a map where the key (string) corresponds to the player's move and value corresponds to another node, which makes a decision tree\n\tvoid CreateSubtree(Chess &c) noexcept;\n\tfloat AlphaBeta(Chess &c, unsigned short &depth, float alpha, float beta, const bool &maximizing_player, const bool &initial_turn) noexcept;\npublic:\n\tstd::string AlphaBetaRoot(Chess &c, unsigned short &difficulty) noexcept;\n};\n\n// bot class declaration, which inherits from player class\nclass Bot : public Player {\nprivate:\n\tPathNode root;\t\t\t\t\t// the root node of the bot's decision tree\n\tunsigned short difficulty;\t\t// the depth of the bot's decision tree\npublic:\n\tBot(const std::string &name, const unsigned short &difficulty) noexcept;\n\tunsigned short GetDifficulty() const noexcept;\n\tstd::string GetIdealMove(Chess &c) noexcept;\n\tstd::string GetIdealMove(Chess &c, unsigned short difficulty) noexcept;\n\tbool operator== (const Bot &b) const noexcept;\n};\n\n// chess class declaration\nclass Chess {\nprivate:\n\tchar board[BOARD_SIZE][BOARD_SIZE];\t\t// game board\n\tBot white, black;\t\t\t\t\t\t// teams\n\tstd::vector<std::pair<Moves, std::string>> all_game_moves;\t\t// a record which contains all the moves played throughout the game in chronological order\n\tbool whites_turn = true;\t\t\t\t// if true then it's team white's turn, if false then it's team black's turn\n\tunsigned short moves_after_last_pawn_move_or_capture = 0;\t\t// number of moves played after a pawn moved or a capture happened\n\tstatic bool WithinBounds(const short &coord) noexcept;\n\tstatic void ChangeToString(char &x1, char &y1, char &x2, char &y2) noexcept;\n\tstatic std::string ToString(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tstatic std::string PieceNameToString(const char &piece) noexcept;\n\tstatic float EvaluatePiece(const char &piece) noexcept;\n\tstatic void ClearAllMoves(const unsigned short &n) noexcept;\n\tstatic void PrintSeparator(const char &ch) noexcept;\n\tstatic void CopyBoard(const char from[BOARD_SIZE][BOARD_SIZE], char to[BOARD_SIZE][BOARD_SIZE]) noexcept;\n\tstatic bool AreBoardsEqual(const char board1[BOARD_SIZE][BOARD_SIZE], const char board2[BOARD_SIZE][BOARD_SIZE]) noexcept;\n\tstatic bool CanMovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const std::forward_list<std::string> &all_moves) noexcept;\n\tBot& GetCurrentPlayer() noexcept;\n\tBot GetCurrentPlayerConst() const noexcept;\n\tBot& GetOtherPlayer() noexcept;\n\tBot GetOtherPlayerConst() const noexcept;\n\tvoid ChangeTurn() noexcept;\n\tvoid AppendToAllGameMoves(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tvoid Reset() noexcept;\n\tvoid CheckCoordinates(const short &x, const short &y, const std::string &func_name) const noexcept(false);\n\tbool EndGameText(const unsigned short &n, const Endgame &end_game) const noexcept;\n\tshort GetEnPassant(const short &x, const short &y) const noexcept;\n\ttemplate<class Iterator> short GetEnPassant(const char board[BOARD_SIZE][BOARD_SIZE], const Iterator &it) const noexcept;\n\tbool ThreefoldRepetition() const noexcept;\n\tbool IsCheck(const bool &turn) const noexcept;\n\tbool IsCheck(std::string &move) noexcept;\n\tstd::forward_list<std::string> PawnMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> RookMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> KnightMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> BishopMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> QueenMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> KingMoves(const short &x, const short &y) const noexcept;\n\tstd::string GetRandomMove() noexcept;\n\tbool ManuallyPromotePawn(const short &x, const short &y) noexcept;\n\tvoid UpdateBoard(const short &x, const short &y) const noexcept;\n\tvoid UpdateScore(const Bot &p) const noexcept;\n\tfloat EvaluatePosition(const short &x, const short &y) const noexcept;\n\tvoid PrintAllMovesMadeInOrder() const noexcept;\n\t\npublic:\n    bool CheckEndgame(const unsigned short &n = 0) noexcept;\n\tChess(const std::string &player1, const unsigned short &difficulty1, const std::string &player2, const unsigned short &difficulty2) noexcept;\n\tstatic void ChangeToRealCoordinates(char &x1, char &y1, char &x2, char &y2) noexcept;\n\tchar GetPiece(const short &x, const short &y) const noexcept;\n\tbool GetTurn() const noexcept;\n\tstd::forward_list<std::string> AllMoves() noexcept;\n\tvoid MovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const bool &manual_promotion, const bool &update_board) noexcept;\n\tvoid MovePieceBack(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tfloat EvaluateBoard(const bool &turn) const noexcept;\n\tvoid PrintBoard() const noexcept;\n\tbool PlayersTurn(std::string s1,std::string s2) noexcept;\n\tbool BotsTurn() noexcept;\n\tbool GameOver() noexcept;\n    std::string GetWinner();\n};\n\n// other function declarations\n\nstd::string ToLowerString(std::string s) noexcept;\ntemplate<class T> T GetRandomNumber(const T &min, const T &max) noexcept;\n\t//CHESS_H\n\n\n// function definitions\n\n// moves the cursor to a different (x, y) location on the terminal\n\n\n// returns the given string in lowercase\nstd::string ToLowerString(std::string s) noexcept {\n\ttransform(s.begin(), s.end(), s.begin(), [](const unsigned char &c){ return tolower(c); });\n\treturn s;\n}\n\n// returns a random number between \"min\" and \"max\"\ntemplate<class T> T GetRandomNumber(const T &min, const T &max) noexcept {\n\treturn min + T(static_cast<double>(rand()) / static_cast<double>(RAND_MAX+1.0) * (max-min+1));\n}\n\n\n\n// chess class implementation\n std::string Chess::GetWinner(){\n    return this->GetOtherPlayerConst().GetName();\n }\n// constructor of chess class\nChess::Chess(const std::string &player1, const unsigned short &difficulty1, const std::string &player2, const unsigned short &difficulty2) noexcept\n: white(player1, difficulty1), black(player2, difficulty2) {\n\tCopyBoard(STARTING_BOARD, board);\n}\n\n// checks whether the given coordinate is within board boundaries or not\nbool Chess::WithinBounds(const short &coord) noexcept {\n\treturn coord>=0 && coord<BOARD_SIZE;\n}\n\n// changes the given board coordinates from ASCII to numerical, e.g. ('d', '3') -> (3, 5)\nvoid Chess::ChangeToRealCoordinates(char &x1, char &y1, char &x2, char &y2) noexcept {\n\tx1 -= 'a', x2 -= 'a';\n\ty1 = '8'-y1, y2 = '8'-y2;\n}\n\n// changes the given board coordinates from numerical to ASCII, e.g. (3, 5) -> ('d', '3')\nvoid Chess::ChangeToString(char &x1, char &y1, char &x2, char &y2) noexcept {\n\tx1 += 'a', x2 += 'a';\n\ty1 = '8'-y1, y2 = '8'-y2;\n}\n\n// returns the given numerical board coordinates as a string\nstd::string Chess::ToString(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\treturn {static_cast<char>(x1+'a'), static_cast<char>('8'-y1), static_cast<char>(x2+'a'), static_cast<char>('8'-y2)};\n}\n\n// returns the name that is displayed on the terminal for the given piece\nstd::string Chess::PieceNameToString(const char &piece) noexcept {\n\tswitch(piece) {\n\t\tcase W_PAWN:\treturn \"W_PAWN\";\n\t\tcase B_PAWN:\treturn \"B_PAWN\";\n\t\tcase W_ROOK:\treturn \"W_ROOK\";\n\t\tcase B_ROOK:\treturn \"B_ROOK\";\n\t\tcase W_KNIGHT:\treturn \"W_KNIGHT\";\n\t\tcase B_KNIGHT:\treturn \"B_KNIGHT\";\n\t\tcase W_BISHOP:\treturn \"W_BISHOP\";\n\t\tcase B_BISHOP:\treturn \"B_BISHOP\";\n\t\tcase W_QUEEN:\treturn \"W_QUEEN\";\n\t\tcase B_QUEEN:\treturn \"B_QUEEN\";\n\t\tcase W_KING:\treturn \"W_KING\";\n\t\tcase B_KING:\treturn \"B_KING\";\n\t\tdefault:\t\treturn \"\";\n\t}\n}\n\n// returns the worth of the given piece in terms of points\nfloat Chess::EvaluatePiece(const char &piece) noexcept {\n\tswitch(piece) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\treturn 10;\t\t// pawn: 10 points\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\treturn 50;\t\t// rook: 50 points\n\t\tcase W_KNIGHT:\n\t\tcase B_KNIGHT:\n\t\tcase W_BISHOP:\n\t\tcase B_BISHOP:\treturn 30;\t\t// knight and bishop: 30 points\n\t\tcase W_QUEEN:\n\t\tcase B_QUEEN:\treturn 90;\t\t// queen: 90 points\n\t\tcase W_KING:\n\t\tcase B_KING:\treturn 900;\t\t// king: 900 points, but you can assume it is infinite\n\t\tdefault:\t\treturn 0;\n\t}\n}\n\n// clears all available moves from the terminal\nvoid Chess::ClearAllMoves(const unsigned short &n) noexcept {\n\n}\n\n// prints the vertical seperators for the game board on the terminal\nvoid Chess::PrintSeparator(const char &ch) noexcept {\n\n}\n\n// copies the board contents of \"from\" to \"to\"\nvoid Chess::CopyBoard(const char from[BOARD_SIZE][BOARD_SIZE], char to[BOARD_SIZE][BOARD_SIZE]) noexcept {\n\tstd::copy(*from, *from + BOARD_SIZE*BOARD_SIZE, *to);\n}\n\n// checks whether the board positions of the given two boards are equal or not\nbool Chess::AreBoardsEqual(const char board1[BOARD_SIZE][BOARD_SIZE], const char board2[BOARD_SIZE][BOARD_SIZE]) noexcept {\n\treturn std::equal(*board1, *board1 + BOARD_SIZE*BOARD_SIZE, *board2);\n}\n\nbool Chess::CanMovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const std::forward_list<std::string> &all_moves) noexcept {\n\treturn std::find(all_moves.cbegin(), all_moves.cend(), ToString(x1, y1, x2, y2)) != all_moves.cend();\n}\n\n// getter method, returns the piece located in the given x and y coordinates\nchar Chess::GetPiece(const short &x, const short &y) const noexcept {\n//\tCheckCoordinates(x, y, \"GetPiece\");\n\treturn board[y][x];\n}\n\n// getter method, returns whether it's team white's turn or not\nbool Chess::GetTurn() const noexcept {\n\treturn whites_turn;\n}\n\n// returns a reference to the player object\nBot& Chess::GetCurrentPlayer() noexcept {\n\treturn whites_turn ? white : black;\n}\n\n// returns a copy of the player object\nBot Chess::GetCurrentPlayerConst() const noexcept {\n\treturn whites_turn ? white : black;\n}\n\n// returns a reference to the player object\nBot& Chess::GetOtherPlayer() noexcept {\n\treturn whites_turn ? black : white;\n}\n\n// returns a copy of the player object\nBot Chess::GetOtherPlayerConst() const noexcept {\n\treturn whites_turn ? black : white;\n}\n\n// changes whose turn it is so the other player can make its move\nvoid Chess::ChangeTurn() noexcept {\n\twhites_turn = !whites_turn;\n}\n\n// appends the last made game move to \"all_game_moves\" list\nvoid Chess::AppendToAllGameMoves(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\tif(GetCurrentPlayerConst().GetCastling() && (board[y1][x1] == B_KING + 7*whites_turn) && (x2 == 2 || x2 == 6))\n\t\tall_game_moves.emplace_back(CASTLING, std::string(1, x2));\n\telse\n\t\tall_game_moves.emplace_back(NORMAL, ToString(x1, y1, x2, y2) + board[y1][x1] + board[y2][x2]);\n}\n\n// resets the game, everything is back to its default value\nvoid Chess::Reset() noexcept {\n\tCopyBoard(STARTING_BOARD, board);\n\twhite.Reset();\n\tblack.Reset();\n\tall_game_moves.clear();\n\twhites_turn = true;\n\tmoves_after_last_pawn_move_or_capture = 0;\n\tsystem(\"cls\");\n}\n\n// a function for exception handling, checks whether the given coordinates is within board boundaries or not\nvoid Chess::CheckCoordinates(const short &x, const short &y, const std::string &func_name) const noexcept(false) {\n\ttry {\n\t\tif(!WithinBounds(x))\t\tthrow x;\n\t\tif(!WithinBounds(y))\t\tthrow y;\n\t}\n\tcatch(const short &coord) {\n\t\tstd::cerr << std::endl << std::endl << TO_RIGHT << \"!ERROR!\\t\\tInvalid coordinate: '\" << coord << \"'.\\t\\t!ERROR!\";\n\t\tstd::cerr << std::endl << TO_RIGHT << \"      \\t\\tException occurred in \\\"\" << func_name << \"\\\".\";\n\t\tPrintAllMovesMadeInOrder();\n\t\texit(1);\n\t}\n}\n\n// prints game over message to the terminal\nbool Chess::EndGameText(const unsigned short &n, const Endgame &end_game) const noexcept {\n\tClearAllMoves(n);\n\n\tswitch(end_game) {\n\t\tcase CHECKMATE:\n\t\t\t\n\t\t\treturn true;\n\t\tdefault:\n\t\t\t//Draw!!!\n\t\t\tswitch(end_game) {\n\t\t\t\tcase FIFTY_MOVES:\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\tcase THREEFOLD_REP:\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t}\n}\n\n// returns the x coordinate of the eaten pawn piece\nshort Chess::GetEnPassant(const short &x, const short &y) const noexcept {\n\tif(all_game_moves.empty())\n\t\treturn -1;\n\tif(all_game_moves.back().first != NORMAL)\n\t\treturn -1;\n\tauto last_move = all_game_moves.back().second;\n\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\treturn ((last_move[4] == W_PAWN - 7*whites_turn) && (abs(last_move[0] - x) == 1) && (last_move[3]-last_move[1] == 2*(whites_turn ? 1 : -1)) && (y == 4 - whites_turn)) ? last_move[0] : -1;\n}\n\n// returns the x coordinate of the en passant move\ntemplate<class Iterator> short Chess::GetEnPassant(const char board[BOARD_SIZE][BOARD_SIZE], const Iterator &it) const noexcept {\n\tif(it->first != NORMAL)\n\t\treturn -1;\n\tauto last_move = it->second;\n\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\tfor(short x=0;x<BOARD_SIZE;++x)\n\t\tif(board[3 + whites_turn][x] == W_PAWN - 7*whites_turn)\n\t\t\tif((last_move[4] == B_PAWN + 7*whites_turn) && (abs(last_move[0] - x) == 1) && (last_move[3] - last_move[1] == 2*(whites_turn ? -1 : 1)))\n\t\t\t\treturn last_move[0];\n\treturn -1;\n}\n\n// returns true if threefold repetition occurs, false otherwise\nbool Chess::ThreefoldRepetition() const noexcept {\n\tstatic char prev_board[BOARD_SIZE][BOARD_SIZE];\n\tCopyBoard(board, prev_board);\n\tunsigned short position_count = 1;\n\tauto it = all_game_moves.crbegin();\n\tauto last_move = it->second;\n\twhile(true) {\n\t\tfor(unsigned short i=0;i<2;++i)\t{\n\t\t\tswitch(it->first) {\n\t\t\t\tcase CASTLING:\n\t\t\t\t\treturn false;\t\t// if a pawn has moved or a castling/capture has occured, then that board position is unique and repetition is not possible\n\t\t\t\tdefault:\n\t\t\t\t\tif(last_move[4] == W_PAWN || last_move[4] == B_PAWN || last_move[5] != EMPTY)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\t\t\t\t\tprev_board[short(last_move[1])][short(last_move[0])] = last_move[4], prev_board[short(last_move[3])][short(last_move[2])] = EMPTY;\n\t\t\t\t\tif(it->first == EN_PASSANT)\n\t\t\t\t\t\tprev_board[short(last_move[1])][short(last_move[2])] = i == whites_turn ? B_PAWN : W_PAWN;\n\t\t\t}\n\t\t\tif((++it) == all_game_moves.crend())\n\t\t\t\treturn false;\n\t\t\tlast_move = it->second;\n\t\t}\n\t\tif(AreBoardsEqual(prev_board, board))\t\t// check for castling and en passant in every 2 turns\n\t\t\tif(GetOtherPlayerConst().GetCastling() == (it->first == CASTLING ? false : last_move[6 + (it->first == PROMOTION)]))\n\t\t\t\tif((all_game_moves.size() > 1 ? GetEnPassant(board, prev(all_game_moves.cend(), 2)) : -1)\n\t\t\t\t== (next(it) == all_game_moves.crend() ? -1 : GetEnPassant(prev_board, next(it))))\n\t\t\t\t\tif((++position_count) == 3)\n\t\t\t\t\t\treturn true;\n\t}\n}\n\n// returns true if the player's king is in check, false otherwise\nbool Chess::IsCheck(const bool &turn) const noexcept {\n\tshort x = -1, y = -1;\n\tfor(short i=0;x==-1;++i)\n\t\tfor(short j=0;j<BOARD_SIZE;++j)\n\t\t\tif(board[j][i] == B_KING + 7*turn) {\n\t\t\t\tx = i, y = j;\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(short i=x+1;i<BOARD_SIZE;++i)\t\t\t\t\t\t// check queen and rook\n\t\tif(board[y][i] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[y][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[y][i] != EMPTY)\tbreak;\n\tfor(short i=x-1;i>=0;--i)\n\t\tif(board[y][i] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[y][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[y][i] != EMPTY)\tbreak;\n\tfor(short i=y+1;i<BOARD_SIZE;++i)\n\t\tif(board[i][x] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[i][x] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[i][x] != EMPTY)\tbreak;\n\tfor(short i=y-1;i>=0;--i)\n\t\tif(board[i][x] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[i][x] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[i][x] != EMPTY)\tbreak;\n\tfor(short i=x-1, j=y-1; i>=0 && j>=0; --i, --j)\t\t\t// check queen and bishop\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x-1, j=y+1; i>=0 && j<BOARD_SIZE; --i, ++j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x+1, j=y-1; i<BOARD_SIZE && j>=0; ++i, --j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x+1, j=y+1; i<BOARD_SIZE && j<BOARD_SIZE; ++i, ++j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x-1;i<x+2;++i)\t\t\t\t\t\t\t\t// check king\n\t\tfor(short j=y-1;j<y+2;++j)\n\t\t\tif((board[j][i] == W_KING - 7*turn) && WithinBounds(i) && WithinBounds(j))\t\t\treturn true;\n\tif((board[y-1][x-2] == W_KNIGHT - 7*turn) && (y > 0) && (x > 1))\t\t\t\t\t\t\treturn true;\t// check knight\n\telse if((board[y-1][x+2] == W_KNIGHT - 7*turn) && (y > 0) && (x < BOARD_SIZE-2))\t\t\treturn true;\n\telse if((board[y+1][x-2] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-1) && (x > 1))\t\t\treturn true;\n\telse if((board[y+1][x+2] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-1) && (x < BOARD_SIZE-2))\treturn true;\n\telse if((board[y-2][x-1] == W_KNIGHT - 7*turn) && (y > 1) && (x > 0))\t\t\t\t\t\treturn true;\n\telse if((board[y-2][x+1] == W_KNIGHT - 7*turn) && (y > 1) && (x < BOARD_SIZE-1))\t\t\treturn true;\n\telse if((board[y+2][x-1] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-2) && (x > 0))\t\t\treturn true;\n\telse if((board[y+2][x+1] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-2) && (x < BOARD_SIZE-1))\treturn true;\n\telse if((board[y + (turn ? -1 : 1)][x+1] == W_PAWN - 7*turn) && (x < BOARD_SIZE-1))\t\t\treturn true;\t// check pawn\n\telse if((board[y + (turn ? -1 : 1)][x-1] == W_PAWN - 7*turn) && (x > 0))\t\t\t\t\treturn true;\n\treturn false;\n}\n\n// function overload, returns true if the player's king is in check, false otherwise\nbool Chess::IsCheck(std::string &move) noexcept {\n\tChangeToRealCoordinates(move[0], move[1], move[2], move[3]);\n\tMovePiece(move[0], move[1], move[2], move[3], false, false);\n\tconst bool &is_check = IsCheck(!whites_turn);\n\tMovePieceBack(move[0], move[1], move[2], move[3]);\n\tChangeToString(move[0], move[1], move[2], move[3]);\n\treturn is_check;\n}\n\n// returns a list of all possible moves the pawn located in (x, y) can make\nstd::forward_list<std::string> Chess::PawnMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tconst short &inc = whites_turn ? -1 : 1;\n\tstd::forward_list<std::string> all_moves;\n\tif(board[y+inc][x] == EMPTY) {\n\t\tall_moves.emplace_front(ToString(x, y, x, y+inc));\t\t\t\t// 1 square forward\n\t\tif((y == 1 + 5*whites_turn) && (board[y + 2*inc][x] == EMPTY))\n\t\t\tall_moves.emplace_front(ToString(x, y, x, y + 2*inc));\t\t// 2 squares forward\n\t}\n\tif(GetEnPassant(x, y) != -1)\n\t\tall_moves.emplace_front(ToString(x, y, GetEnPassant(x, y), y+inc));\n\tif(IsValid(board[y+inc][x+1]) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y+inc));\t\t// diagonal attack moves\n\tif(IsValid(board[y+inc][x-1]) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y+inc));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the rook located in (x, y) can make\nstd::forward_list<std::string> Chess::RookMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x+1;i<BOARD_SIZE;++i)\t\t\t// right\n\t\tif(board[y][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\telse {\n\t\t\tif(IsValid(board[y][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x-1;i>=0;--i)\t\t\t\t\t// left\n\t\tif(board[y][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\telse {\n\t\t\tif(IsValid(board[y][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=y+1;i<BOARD_SIZE;++i)\t\t\t// down\n\t\tif(board[i][x] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\telse {\n\t\t\tif(IsValid(board[i][x]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=y-1;i>=0;--i)\t\t\t\t\t// up\n\t\tif(board[i][x] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\telse {\n\t\t\tif(IsValid(board[i][x]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\t\tbreak;\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the knight located in (x, y) can make\nstd::forward_list<std::string> Chess::KnightMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch <= 0; } : [](const char &ch){ return ch >= 0; };\n\tstd::forward_list<std::string> all_moves;\n\tif(IsValid(board[y-1][x-2]) && (y > 0) && (x > 1))\n\t\tall_moves.emplace_front(ToString(x, y, x-2, y-1));\n\tif(IsValid(board[y-1][x+2]) && (y > 0) && (x < BOARD_SIZE-2))\n\t\tall_moves.emplace_front(ToString(x, y, x+2, y-1));\n\tif(IsValid(board[y+1][x-2]) && (y < BOARD_SIZE-1) && (x > 1))\n\t\tall_moves.emplace_front(ToString(x, y, x-2, y+1));\n\tif(IsValid(board[y+1][x+2]) && (y < BOARD_SIZE-1) && (x < BOARD_SIZE-2))\n\t\tall_moves.emplace_front(ToString(x, y, x+2, y+1));\n\tif(IsValid(board[y-2][x-1]) && (y > 1) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y-2));\n\tif(IsValid(board[y-2][x+1]) && (y > 1) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y-2));\n\tif(IsValid(board[y+2][x-1]) && (y < BOARD_SIZE-2) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y+2));\n\tif(IsValid(board[y+2][x+1]) && (y < BOARD_SIZE-2) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y+2));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the bishop located in (x, y) can make\nstd::forward_list<std::string> Chess::BishopMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x-1, j=y-1; i>=0 && j>=0; --i, --j)\t\t\t\t\t\t// upper left diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x-1, j=y+1; i>=0 && j<BOARD_SIZE; --i, ++j)\t\t\t\t// lower left diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x+1, j=y-1; i<BOARD_SIZE && j>=0; ++i, --j)\t\t\t\t// upper right diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x+1, j=y+1; i<BOARD_SIZE && j<BOARD_SIZE; ++i, ++j)\t\t// lower right diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the queen located in (x, y) can make\nstd::forward_list<std::string> Chess::QueenMoves(const short &x, const short &y) const noexcept {\n\tauto all_moves = RookMoves(x, y);\t\t\t// queen = rook + bishop\n\tall_moves.merge(BishopMoves(x, y));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the king located in (x, y) can make\nstd::forward_list<std::string> Chess::KingMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch <= 0; } : [](const char &ch){ return ch >= 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x-1;i<x+2;++i)\t\t// add moves within 1 square reach\n\t\tfor(short j=y-1;j<y+2;++j)\n\t\t\tif(IsValid(board[j][i]) && WithinBounds(i) && WithinBounds(j))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\tif(GetCurrentPlayerConst().GetCastling())\t\t// add castling moves if castling is possible\n\t\tif(!IsCheck(whites_turn)) {\n\t\t\tconst short &line = (BOARD_SIZE-1)*whites_turn;\n\t\t\tif((board[line][0] == B_ROOK + 7*whites_turn) && board[line][1] == EMPTY && board[line][2] == EMPTY && board[line][3] == EMPTY)\n\t\t\t\tall_moves.emplace_front(ToString(4, line, 2, line));\t// long castling\n\t\t\telse if((board[line][7] == B_ROOK + 7*whites_turn) && board[line][5] == EMPTY && board[line][6] == EMPTY)\n\t\t\t\tall_moves.emplace_front(ToString(4, line, 6, line));\t// short castling\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the player can make\nstd::forward_list<std::string> Chess::AllMoves() noexcept {\n\tstd::forward_list<std::string> all_moves;\n\tfor(short y=0;y<BOARD_SIZE;++y)\n\t\tfor(short x=0;x<BOARD_SIZE;++x) {\n\t\t\tif((board[y][x] < 0) == whites_turn)\n\t\t\t\tcontinue;\n\t\t\tswitch(board[y][x]) {\n\t\t\t\tcase W_PAWN:\n\t\t\t\tcase B_PAWN:\n\t\t\t\t\tall_moves.merge(PawnMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_ROOK:\n\t\t\t\tcase B_ROOK:\n\t\t\t\t\tall_moves.merge(RookMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_KNIGHT:\n\t\t\t\tcase B_KNIGHT:\n\t\t\t\t\tall_moves.merge(KnightMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_BISHOP:\n\t\t\t\tcase B_BISHOP:\n\t\t\t\t\tall_moves.merge(BishopMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_QUEEN:\n\t\t\t\tcase B_QUEEN:\n\t\t\t\t\tall_moves.merge(QueenMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_KING:\n\t\t\t\tcase B_KING:\n\t\t\t\t\tall_moves.merge(KingMoves(x, y));\n\t\t\t}\n\t\t}\n\tfor(auto it = all_moves.begin(), prev = all_moves.before_begin(); it != all_moves.cend();)\t\t// if the possible move makes me checkmate after the opponent's turn, remove it from the list\n\t\tif(IsCheck(*it))\n\t\t\tit = all_moves.erase_after(prev);\n\t\telse\n\t\t\t++it, ++prev;\n\treturn all_moves;\n}\n\n// returns a random move the player can make\nstd::string Chess::GetRandomMove() noexcept {\n\tauto all_moves = AllMoves();\n\tauto move = all_moves.begin();\n\tadvance(move, GetRandomNumber<unsigned short>(0, distance(all_moves.cbegin(), all_moves.cend()) - 1));\n\tChangeToRealCoordinates((*move)[0], (*move)[1], (*move)[2], (*move)[3]);\n\treturn *move;\n}\n\n// asks the player it's choice of promotion, then promotes the pawn to the desired piece\nbool Chess::ManuallyPromotePawn(const short &x, const short &y) noexcept {\n\t\n\tchar key = 'q';\n\t\n\t\n\t\tswitch(key = tolower(key)) {\n\t\t\tcase 'r':\tboard[y][x] = whites_turn ? W_ROOK : B_ROOK;\t\treturn true;\n\t\t\tcase 'k':\tboard[y][x] = whites_turn ? W_KNIGHT : B_KNIGHT;\treturn true;\n\t\t\tcase 'b':\tboard[y][x] = whites_turn ? W_BISHOP : B_BISHOP;\treturn true;\n\t\t\tcase 'q':\tboard[y][x] = whites_turn ? W_QUEEN : B_QUEEN;\t\treturn true;\n\n\t\t}\n\t\treturn false;\n}\n\n// moves the piece from (x1, y1) to (x2, y2)\nvoid Chess::MovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const bool &manual_promotion, const bool &update_board) noexcept {\n//\tCheckCoordinates(x1, y1, \"MovePiece\");\n//\tCheckCoordinates(x2, y2, \"MovePiece\");\n\t\n\tAppendToAllGameMoves(x1, y1, x2, y2);\t\t// similar to FEN notation but not really, the starting and ending points of the moving piece, promoted piece if there is promotion and ability to do castling\n\tswitch(board[y1][x1]) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\n\t\t\tif(y2 == ((BOARD_SIZE-1) * !whites_turn)) {\t\t\t// check for castling, promotion or en passant\n\t\t\t\tif(manual_promotion) {\n\t\t\t\t\tManuallyPromotePawn(x1, y1);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(whites_turn ? WHITE_BOT_RANDOM : BLACK_BOT_RANDOM)\n\t\t\t\t\tboard[y1][x1] = (whites_turn ? 1 : -1) * GetRandomNumber(2, 5);\n\t\t\t\telse\n\t\t\t\t\tboard[y1][x1] = whites_turn ? W_QUEEN : B_QUEEN;\n\t\t\t\tall_game_moves.back().first = PROMOTION;\n\t\t\t\tall_game_moves.back().second.push_back(board[y1][x1]);\n\t\t\t}\n\t\t\telse if(x1 != x2 && board[y2][x2] == EMPTY) {\n\t\t\t\tboard[y1][x2] = EMPTY;\n\t\t\t\tif(update_board) {\n\t\t\t\t\tGetCurrentPlayer().IncreaseScore(EvaluatePiece(W_PAWN));\n\t\t\t\t\tUpdateScore(GetCurrentPlayerConst());\n\t\t\t\t\tUpdateBoard(x2, y1);\n\t\t\t\t}\n\t\t\t\tall_game_moves.back().first = EN_PASSANT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase W_KING:\n\t\tcase B_KING:\n\t\t\tif(GetCurrentPlayerConst().GetCastling()) {\n\t\t\t\tconst short &line = (BOARD_SIZE-1) * whites_turn;\n\t\t\t\tswitch(x2) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tboard[line][3] = board[line][0], board[line][0] = EMPTY;\n\t\t\t\t\t\tif(update_board) {\n\t\t\t\t\t\t\tUpdateBoard(0, line);\n\t\t\t\t\t\t\tUpdateBoard(3, line);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tboard[line][5] = board[line][7], board[line][7] = EMPTY;\n\t\t\t\t\t\tif(update_board) {\n\t\t\t\t\t\t\tUpdateBoard(7, line);\n\t\t\t\t\t\t\tUpdateBoard(5, line);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\n\t\t\tGetCurrentPlayer().SetCastling(false);\n\t}\n\tif(all_game_moves.back().first != CASTLING)\t\t\t\tall_game_moves.back().second.push_back(GetCurrentPlayerConst().GetCastling());\n\tboard[y2][x2] = board[y1][x1], board[y1][x1] = EMPTY;\n\tif(update_board) {\n\t\tif(all_game_moves.back().first != CASTLING)\n\t\t\tif(all_game_moves.back().second[5] != EMPTY) {\n\t\t\t\tGetCurrentPlayer().IncreaseScore(EvaluatePiece(all_game_moves.back().second[5]));\n\t\t\t\tUpdateScore(GetCurrentPlayerConst());\n\t\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// the piece is eaten\n\t\t\t}\n\t\tUpdateBoard(x1, y1);\n\t\tUpdateBoard(x2, y2);\n\t}\n\tChangeTurn();\t\t// it's the opponent's turn\n}\n\n// undoes the move from (x1,y1) to (x2,y2), the opposite of the \"MovePiece\" function\nvoid Chess::MovePieceBack(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\tChangeTurn();\n\tboard[y1][x1] = board[y2][x2], board[y2][x2] = all_game_moves.back().first == CASTLING ? static_cast<char>(EMPTY) : all_game_moves.back().second[5];\n\tswitch(board[y1][x1]) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\n\t\t\tif(x1 != x2 && board[y2][x2] == EMPTY)\n\t\t\t\tboard[y1][x2] = whites_turn ? B_PAWN : W_PAWN;\n\t\t\tbreak;\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\n\t\t\tif(prev(all_game_moves.cend(), 3)->first != CASTLING)\n\t\t\t\tif(prev(all_game_moves.cend(), 3)->second[6 + (prev(all_game_moves.cend(), 3)->first == PROMOTION)])\n\t\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t\t\tbreak;\n\t\tcase W_QUEEN:\n\t\tcase B_QUEEN:\n\t\t\tif(all_game_moves.back().first == PROMOTION)\n\t\t\t\tboard[y1][x1] = whites_turn ? W_PAWN : B_PAWN;\n\t\t\tbreak;\n\t\tcase W_KING:\n\t\tcase B_KING:\n\t\t\tif(all_game_moves.back().first == CASTLING) {\n\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t\t\t\tconst short line = (BOARD_SIZE-1) * whites_turn;\n\t\t\t\tswitch(x2) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tboard[line][0] = board[line][3], board[line][3] = EMPTY;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tboard[line][7] = board[line][5], board[line][5] = EMPTY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(prev(all_game_moves.cend(), 3)->first != CASTLING)\n\t\t\t\tif(prev(all_game_moves.cend(), 3)->second[6 + (prev(all_game_moves.cend(), 3)->first == PROMOTION)])\n\t\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t}\n\tall_game_moves.pop_back();\n}\n\n// updates the board display on the terminal\nvoid Chess::UpdateBoard(const short &x, const short &y) const noexcept {\n\tconst unsigned short &diff = BOX_WIDTH - PieceNameToString(board[y][x]).length();\n\t\n}\n\n// updates the score display on the terminal\nvoid Chess::UpdateScore(const Bot &p) const noexcept {\n\tconst unsigned short &dx = p==white ? white.GetName().length() + 2 : (BOX_WIDTH+1)*BOARD_SIZE - 5;\n\t\n\n}\n\n// returns the worth of the position of the piece in terms of points\nfloat Chess::EvaluatePosition(const short &x, const short &y) const noexcept {\n\tif(board[y][x] == EMPTY)\n\t\treturn 0;\n\tstatic float PIECE_POS_POINTS[6][BOARD_SIZE][BOARD_SIZE] =\n\t{{{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\t\t// king\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-2.0, -3.0, -3.0, -4.0, -4.0, -3.0, -3.0, -2.0},\n\t{-1.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -1.0},\n\t{2.0, 2.0, 0.0, 0.0, 0.0, 0.0, 2.0, 2.0},\n\t{2.0, 3.0, 1.0, 0.0, 0.0, 1.0, 3.0, 2.0}}\n\t,\n\t{{-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0},\t\t// queen\n\t{-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0},\n\t{-0.5, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5},\n\t{0.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5},\n\t{-1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0}}\n\t,\n\t{{-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0},\t\t// bishop\n\t{-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 1.0, 1.0, 0.5, 0.0, -1.0},\n\t{-1.0, 0.5, 0.5, 1.0, 1.0, 0.5, 0.5, -1.0},\n\t{-1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, -1.0},\n\t{-1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0},\n\t{-1.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, -1.0},\n\t{-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0}}\n\t,\n\t{{-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0},\t\t// knight\n\t{-4.0, -2.0, 0.0, 0.0, 0.0, 0.0, -2.0, -4.0},\n\t{-3.0, 0.0, 1.0, 1.5, 1.5, 1.0, 0.0, -3.0},\n\t{-3.0, 0.5, 1.5, 2.0, 2.0, 1.5, 0.5, -3.0},\n\t{-3.0, 0.0, 1.5, 2.0, 2.0, 1.5, 0.0, -3.0},\n\t{-3.0, 0.5, 1.0, 1.5, 1.5, 1.0, 0.5, -3.0},\n\t{-4.0, -2.0, 0.0, 0.5, 0.5, 0.0, -2.0, -4.0},\n\t{-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0}}\n\t,\n\t{{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\t\t\t\t// rook\n\t{0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0}}\n\t,\n\t{{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\t\t\t\t// pawn\n\t{5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0},\n\t{1.0, 1.0, 2.0, 3.0, 3.0, 2.0, 1.0, 1.0},\n\t{0.5, 0.5, 1.0, 2.5, 2.5, 1.0, 0.5, 0.5},\n\t{0.0, 0.0, 0.0, 2.0, 2.0, 0.0, 0.0, 0.0},\n\t{0.5, -0.5, -1.0, 0.0, 0.0, -1.0, -0.5, 0.5},\n\t{0.5, 1.0, 1.0, -2.0, -2.0, 1.0, 1.0, 0.5},\n\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}}};\t\t\t\t// returns negative points if the pieces are black, positive points if the pieces are white\n\treturn (board[y][x]<0 ? -1 : 1) * (EvaluatePiece(board[y][x]) + PIECE_POS_POINTS[board[y][x] + 7*(board[y][x]<0) - 1][board[y][x]<0 ? BOARD_SIZE-y-1 : y][x]);\n}\n\n// returns the worth of the board position in terms of points\nfloat Chess::EvaluateBoard(const bool &turn) const noexcept {\n\tfloat total_evaluation = 0.0;\n\tfor(short y=0;y<BOARD_SIZE;++y)\n\t\tfor(short x=0;x<BOARD_SIZE;++x)\n\t\t\ttotal_evaluation += EvaluatePosition(x, y);\n\treturn (turn ? 1 : -1) * total_evaluation;\n}\n\n// prints the game board on the terminal\nvoid Chess::PrintBoard() const noexcept {\n\tstd::cout << TO_DOWN << TO_RIGHT;\n\tfor(short y=0;y<BOARD_SIZE;++y) {\n\t\tPrintSeparator(' ');\n\t\tstd::cout << \"\\b\\b\\b\" << BOARD_SIZE-y << \"  \";\n\t\tfor(short x=0;x<BOARD_SIZE;++x) {\n\t\t\tconst unsigned short &diff = BOX_WIDTH - PieceNameToString(board[y][x]).length();\n\t\t\tstd::cout << std::string(diff/2, ' ') << PieceNameToString(board[y][x]) << std::string(diff/2, ' ');\n\t\t\tif(diff%2)\t\t\t\tstd::cout << \" \";\n\t\t\tif(x < BOARD_SIZE-1)\tstd::cout << \"|\";\n\t\t}\n\t\tif(y < BOARD_SIZE-1) {\n\t\t\tstd::cout << std::endl << TO_RIGHT;\n\t\t\tPrintSeparator('_');\n\t\t}\n\t}\n\tstd::cout << std::endl << TO_RIGHT;\n\tPrintSeparator(' ');\n\tfor(char ch='a';ch<'a'+BOARD_SIZE;++ch)\n\t\tstd::cout << std::string(BOX_WIDTH/2, ' ') << ch << std::string(BOX_WIDTH/2, ' ');\n\tstd::cout << std::endl << std::endl << TO_RIGHT << white.GetName() << \": 0\";\n\tstd::cout << std::string((BOX_WIDTH+1)*BOARD_SIZE - white.GetName().length() - black.GetName().length() - 10, ' ') << black.GetName() << \": 0\";\n\tstd::cout << std::endl << std::endl << TO_RIGHT << white.GetName() << \"'s turn...\";\n\tstd::cout << std::endl << TO_RIGHT << \"Enter move coordinates (x1,y1)->(x2,y2):\";\n\tstd::cout << std::endl << std::endl << TO_RIGHT << \"All possible moves:\" << std::endl;\n}\n\n// after the game is over, prints all moves played throughout the game in chronological order\nvoid Chess::PrintAllMovesMadeInOrder() const noexcept {\n\tstd::cout << std::endl << std::endl << TO_RIGHT << \"All moves made in order:\" << std::endl;\n\tbool turn = true;\n\tfor(const auto &game_move : all_game_moves) {\n\t\tstd::cout << std::endl << TO_RIGHT << (turn ? white : black).GetName() << \": \";\n\t\tswitch(game_move.first) {\n\t\t\tcase CASTLING:\n\t\t\t\tstd::cout << \"castling \" << (game_move.second[0] == 2 ? \"long\" : \"short\");\tbreak;\n\t\t\tdefault:\n\t\t\t\tstd::cout << ToLowerString(PieceNameToString(game_move.second[4])).substr(2) << \" '\" << game_move.second.substr(0, 2) << \"' to \";\n\t\t\t\tif(game_move.second[5] != EMPTY)\n\t\t\t\t\tstd::cout << ToLowerString(PieceNameToString(game_move.second[5])).substr(2) + \" \";\n\t\t\t\tstd::cout << \"'\" << game_move.second.substr(2, 2) << \"'\";\n\t\t\t\tswitch(game_move.first) {\n\t\t\t\t\tcase PROMOTION:\n\t\t\t\t\t\tstd::cout << \" promoted to \" << ToLowerString(PieceNameToString(game_move.second[6])).substr(2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EN_PASSANT:\n\t\t\t\t\t\tstd::cout << \" (en passant)\";\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tturn = !turn;\n\t}\n}\n\n// checks if the game is over or not\nbool Chess::CheckEndgame(const unsigned short &n) noexcept {\n\tif(AllMoves().empty()) {\t\t\t// if the opponent has no moves left, then it is checkmate\n\t\tGetOtherPlayer().IncreaseScore(EvaluatePiece(W_KING));\n\t\tUpdateScore(GetOtherPlayerConst());\n\t\treturn EndGameText(n, CHECKMATE);\n\t}\n\telse if(all_game_moves.back().first != CASTLING) {\n\t\tif(all_game_moves.back().second[4] == W_PAWN - 7*whites_turn)\n\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// pawn has moved\n\t\telse if(all_game_moves.back().second[5] != EMPTY)\n\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// capture has occured\n\t\telse if((++moves_after_last_pawn_move_or_capture) == 50)\n\t\t\treturn EndGameText(n, FIFTY_MOVES);\n\t}\n\telse if((++moves_after_last_pawn_move_or_capture) == 50)\n\t\treturn EndGameText(n, FIFTY_MOVES);\n\tif(ThreefoldRepetition())\n\t\treturn EndGameText(n, THREEFOLD_REP);\n\treturn false;\n}\n\n// lists all possible moves, expects player input and plays the given move if it is valid, expects a valid input otherwise\nbool Chess::PlayersTurn(std::string from,std::string to) noexcept {\n\tauto all_moves = AllMoves();\n\tall_moves.sort();\n\tunsigned short i=0;\n\t\n\tif(IsCheck(whites_turn)) {\n\t\t\n\t\ti += 2*MOVES_PER_LINE;\n\t}\n\t\n\twhile(true) {\n\t\t\n\t\t\n\t\tif(!ToLowerString(from).compare(\"quit\"))\n\t\t\treturn EndGameText(i/MOVES_PER_LINE + 1, QUIT);\n\t\tif(!ToLowerString(from).compare(\"exit\"))\n\t\t\treturn EndGameText(i/MOVES_PER_LINE + 1, QUIT);\n\t\t\n\t\tfrom.resize(2);\n\t\tto.resize(2);\n\t\tfrom.shrink_to_fit();\n\t\tto.shrink_to_fit();\n\t\tfrom[0] = tolower(from[0]), to[0] = tolower(to[0]);\n\t\tChangeToRealCoordinates(from[0], from[1], to[0], to[1]);\n       \n\t\tif((from[0]!=to[0] || from[1]!=to[1]) && WithinBounds(from[0]) && WithinBounds(from[1]) && WithinBounds(to[0]) && WithinBounds(to[1])){\n\t\t\tif(CanMovePiece(from[0], from[1], to[0], to[1], all_moves)) {\n\t\t\t\tMovePiece(from[0], from[1], to[0], to[1], true, true);\n\t\t\t\tif(CheckEndgame(i/MOVES_PER_LINE + 1))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\t}else{\n                return false;\n            }\n        }else{\n            return false;\n        }\n\t\t\n\t\t\n\t}\n\t\n\tClearAllMoves(i/MOVES_PER_LINE + 1);\n\t\n\treturn true;\n}\n\n// plays the bots move\nbool Chess::BotsTurn() noexcept {\n\tconst auto &move = (whites_turn ? WHITE_BOT_RANDOM : BLACK_BOT_RANDOM) ? GetRandomMove() : GetCurrentPlayer().GetIdealMove(*this);\n\tMovePiece(move[0], move[1], move[2], move[3], false, true);\n\tif(CheckEndgame())\n\t\treturn false;\n\t\n\treturn true;\n}\n\n// prints game over messages and expects user input for another game\nbool Chess::GameOver() noexcept {\n\t//std::cout << std::endl << std::endl << std::endl << TO_RIGHT << \"Press R to play again.\";\n\t//std::cout << std::endl << TO_RIGHT << \"Press any other key to quit.\";\n\t//PrintAllMovesMadeInOrder();\n\tchar key = 'a';\n\tswitch(key = tolower(key)) {\n\t\tcase 'r':\n\t\t\tReset();\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n\n\n\n\n\n// bot class constructor\nBot::Bot(const std::string &name, const unsigned short &difficulty) noexcept : Player(name), difficulty(difficulty) {\t}\n\n// getter method, returns the difficulty level of the bot\nunsigned short Bot::GetDifficulty() const noexcept {\n\treturn difficulty;\n}\n\n// returns the optimal move the bot can make with the default difficulty level (according to alpha-beta pruning at least)\nstd::string Bot::GetIdealMove(Chess &c) noexcept {\n\treturn root.AlphaBetaRoot(c, difficulty);\n}\n\n// function overload, returns the optimal move the bot can make with the given difficulty level\nstd::string Bot::GetIdealMove(Chess &c, unsigned short difficulty) noexcept {\n\treturn root.AlphaBetaRoot(c, difficulty);\n}\n\n// operator overload for '=='\nbool Bot::operator== (const Bot &b) const noexcept {\n\treturn !name.compare(b.name);\t\n}\n\n\n\n\n\n// player class constructor\nPlayer::Player(const std::string &name) noexcept : name(name) {\t}\n\n// getter method which returns the name of the player\nstd::string Player::GetName() const noexcept {\n\treturn name;\n}\n\n// getter method which returns the score of the player\nunsigned short Player::GetScore() const noexcept {\n\treturn score;\n}\n\n// getter method which returns whether the player can castle or not\nbool Player::GetCastling() const noexcept {\n\treturn castling;\n}\n\n// setter method which sets whether the player can castle or not\nvoid Player::SetCastling(const bool &castling) noexcept {\n\tthis->castling = castling;\n}\n\n// increases the score by an amount of \"inc\" points\nvoid Player::IncreaseScore(const unsigned short &inc) noexcept {\n\tscore += inc;\n}\n\n// resets the score and the ability to castle to their initial values\nvoid Player::Reset() noexcept {\n\tscore = 0;\n\tcastling = true;\n}\n\n// operator overload for '=='\nbool Player::operator== (const Player &p) const noexcept {\n\treturn !name.compare(p.name);\n}\n\n\n\n\n\n\n// creates a subtree which contains all possible moves the player can make\nvoid PathNode::CreateSubtree(Chess &c) noexcept {\n\tauto all_moves = c.AllMoves();\t\t\t\t\t// add all possible moves to the Node's map\n\tfor(auto &move : all_moves) {\n\t\tChess::ChangeToRealCoordinates(move[0], move[1], move[2], move[3]);\n\t\tchild_node_list.emplace(move, PathNode());\n\t}\n}\n\n// returns the maximum score for the minimizing player and the minimum score for the maximizing player in each recursion\nfloat PathNode::AlphaBeta(Chess &c, unsigned short &depth, float alpha, float beta, const bool &maximizing_player, const bool &initial_turn) noexcept {\n\tif(!depth)\n\t\treturn c.EvaluateBoard(initial_turn);\n\tCreateSubtree(c);\n\tfloat points = maximizing_player ? -9999 : 9999;\n\tfor(auto &node : child_node_list) {\t\t\t\t\t\t// 1-0: from, 3-2: to\n\t\tif(c.GetPiece(node.first[2], node.first[3]) == W_KING - 7*c.GetTurn()) {\n\t\t\tchild_node_list.clear();\n\t\t\treturn maximizing_player ? 9999 : -9999;\t\t// if my target piece is king, then it is the most rewarding move\n\t\t}\n\t\tc.MovePiece(node.first[0], node.first[1], node.first[2], node.first[3], false, false);\n\t\tpoints = maximizing_player ? std::max(points, node.second.AlphaBeta(c, --depth, alpha, beta, false, initial_turn))\t\t// recursive alpha-beta algorithm\n\t\t: std::min(points, node.second.AlphaBeta(c, --depth, alpha, beta, true, initial_turn));\n\t\tmaximizing_player ? alpha = std::max(alpha, points) : beta = std::min(beta, points);\n\t\t++depth;\n\t\tc.MovePieceBack(node.first[0], node.first[1], node.first[2], node.first[3]);\n\t\tif(alpha >= beta)\n\t\t\tbreak;\n\t}\n\tchild_node_list.clear();\n\treturn points;\n}\n\n// the main function which returns the optimal move calculated by the alpha-beta algorithm\nstd::string PathNode::AlphaBetaRoot(Chess &c, unsigned short &difficulty) noexcept {\n\tCreateSubtree(c);\n\tstd::vector<std::string> ideal_moves;\n\tfloat max_move_score = -9999;\n\tfor(auto &node : child_node_list) {\n\t\tif(c.GetPiece(node.first[2], node.first[3]) == W_KING - 7*c.GetTurn()) {\n\t\t\tchild_node_list.clear();\n\t\t\treturn node.first;\t\t\t\t\t\t// if my target piece is king, then this move is a game winner so return this move\n\t\t}\n\t\tc.MovePiece(node.first[0], node.first[1], node.first[2], node.first[3], false, false);\n\t\tfloat move_score = node.second.AlphaBeta(c, difficulty, -10000, 10000, false, !c.GetTurn());\n\t\tif(move_score > max_move_score) {\n\t\t\tmax_move_score = move_score;\n\t\t\tideal_moves.clear();\n\t\t\tideal_moves.emplace_back(node.first);\t// add the most rewarding move to the list\n\t\t}\n\t\telse if(move_score == max_move_score)\n\t\t\tideal_moves.emplace_back(node.first);\n\t\tc.MovePieceBack(node.first[0], node.first[1], node.first[2], node.first[3]);\n\t}\n\tchild_node_list.clear();\t\t\t\t\t\t// delete the whole tree\n\tauto move = ideal_moves.cbegin();\n\tadvance(move, GetRandomNumber<unsigned short>(0, ideal_moves.size()-1));\n\treturn *move;\n}\n\n\n\nint main(){\n\n    Chess c(\"0\", WHITE_BOT_DIFFICULTY, \"1\", BLACK_BOT_DIFFICULTY);\n    std::string s1,s2;\n   \n    int i = 0;\n    std::cout << i << std::endl;\n    std::cout << -1 <<\" \" << -1<<std::endl;\n    std::cin >> s1 >> s2;\n    \n    \n    while(c.PlayersTurn(s1,s2)){\n        i++;\n        i%=2;\n\t\tif(c.CheckEndgame()){\n\t\t\tbreak;\n\t\t}\n        std::cout << i << std::endl;\n        std::cout << s1 <<\" \" << s2<<std::endl;\n        std::cin >> s1 >> s2;  \n\n    };\n    \n\n    \n   std::cout << -1 << std::endl <<c.GetWinner() << std::endl;\n    return 0;\n}";

    private readonly string chess_bot1_cpp =
        "\n\n#define BOARD_SIZE 8\n#define BOX_WIDTH 10\n#define DOWN 3\n#define RIGHT 10\n#define TO_DOWN std::string(DOWN, '\\n')\n#define TO_RIGHT std::string(RIGHT, ' ')\n#define CLEAR_LINE std::string(100, ' ')\n#define MOVES_PER_LINE 5\n\n#define AGAINST_BOT true\t\t\t// if true then it's ? vs bot, if false then it's player vs player\n#define TWO_BOTS true\t\t\t\t// assuming AGAINST_BOT is true, if true then it's bot vs bot, if false then it's player vs bot\n#define BOT_IS_WHITE false\t\t\t// assuming AGAINST_BOT is true and TWO_BOTS is false, if true then the bot is team white, black otherwise\n#define WHITE_BOT_RANDOM true\t\t// if true the white bot returns random moves, if false the white bot returns smart moves generated by minimax algorithm\n#define BLACK_BOT_RANDOM false\t\t// if true the black bot returns random moves, if false the black bot returns smart moves generated by minimax algorithm\n#define WHITE_BOT_DIFFICULTY 1\t\t// the tree depth of decision tree of the bot, which is also correlated to the bot's difficulty (aka chess IQ)\n#define BLACK_BOT_DIFFICULTY 1\t\t// 1: easy, 2: medium, 3: hard\n\n// types of chess pieces\ntypedef enum {\n\tB_KING = -6, B_QUEEN, B_BISHOP, B_KNIGHT, B_ROOK, B_PAWN, EMPTY,\n\tW_KING, W_QUEEN, W_BISHOP, W_KNIGHT, W_ROOK, W_PAWN\n} ChessPieces;\n\n// types of player moves\ntypedef enum {\n\tNORMAL, CASTLING, PROMOTION, EN_PASSANT\n} Moves;\n\n// possible options on how the game can end\ntypedef enum {\n\tCHECKMATE, FIFTY_MOVES, THREEFOLD_REP, QUIT\n} Endgame;\n\n// starting position of the board\nconst char STARTING_BOARD[BOARD_SIZE][BOARD_SIZE] = {{B_ROOK, B_KNIGHT, B_BISHOP, B_QUEEN, B_KING, B_BISHOP, B_KNIGHT, B_ROOK},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{W_ROOK, W_KNIGHT, W_BISHOP, W_QUEEN, W_KING, W_BISHOP, W_KNIGHT, W_ROOK}};\n\nclass Player;\nclass PathNode;\nclass Bot;\nclass Chess;\n\n#include <string>\n#include <forward_list>\n#include <vector>\n#include <map>\n#include <iostream>\n#include <algorithm>\n\n\n\n\n// player class declaration\nclass Player {\nprotected:\n\tstd::string name;\t\t\t// name of the player\n\tunsigned short score = 0;\t// score of the player\n\tbool castling = true;\t\t// if true the player can castle, if false the player cannot castle anymore during the game\npublic:\n\tPlayer(const std::string &name) noexcept;\n\tstd::string GetName() const noexcept;\n\tunsigned short GetScore() const noexcept;\n\tbool GetCastling() const noexcept;\n\tvoid SetCastling(const bool &castling) noexcept;\n\tvoid IncreaseScore(const unsigned short &inc) noexcept;\n\tvoid Reset() noexcept;\n\tbool operator== (const Player &p) const noexcept;\n};\n\n// path node class declaration\nclass PathNode {\nprivate:\n\tstd::map<std::string, PathNode> child_node_list;\t// a map where the key (string) corresponds to the player's move and value corresponds to another node, which makes a decision tree\n\tvoid CreateSubtree(Chess &c) noexcept;\n\tfloat AlphaBeta(Chess &c, unsigned short &depth, float alpha, float beta, const bool &maximizing_player, const bool &initial_turn) noexcept;\npublic:\n\tstd::string AlphaBetaRoot(Chess &c, unsigned short &difficulty) noexcept;\n};\n\n// bot class declaration, which inherits from player class\nclass Bot : public Player {\nprivate:\n\tPathNode root;\t\t\t\t\t// the root node of the bot's decision tree\n\tunsigned short difficulty;\t\t// the depth of the bot's decision tree\npublic:\n\tBot(const std::string &name, const unsigned short &difficulty) noexcept;\n\tunsigned short GetDifficulty() const noexcept;\n\tstd::string GetIdealMove(Chess &c) noexcept;\n\tstd::string GetIdealMove(Chess &c, unsigned short difficulty) noexcept;\n\tbool operator== (const Bot &b) const noexcept;\n};\n\n// chess class declaration\nclass Chess {\nprivate:\n\tchar board[BOARD_SIZE][BOARD_SIZE];\t\t// game board\n\tBot white, black;\t\t\t\t\t\t// teams\n\tstd::vector<std::pair<Moves, std::string>> all_game_moves;\t\t// a record which contains all the moves played throughout the game in chronological order\n\tbool whites_turn = true;\t\t\t\t// if true then it's team white's turn, if false then it's team black's turn\n\tunsigned short moves_after_last_pawn_move_or_capture = 0;\t\t// number of moves played after a pawn moved or a capture happened\n\tstatic bool WithinBounds(const short &coord) noexcept;\n\tstatic void ChangeToString(char &x1, char &y1, char &x2, char &y2) noexcept;\n\tstatic std::string ToString(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tstatic std::string PieceNameToString(const char &piece) noexcept;\n\tstatic float EvaluatePiece(const char &piece) noexcept;\n\tstatic void ClearAllMoves(const unsigned short &n) noexcept;\n\tstatic void PrintSeparator(const char &ch) noexcept;\n\tstatic void CopyBoard(const char from[BOARD_SIZE][BOARD_SIZE], char to[BOARD_SIZE][BOARD_SIZE]) noexcept;\n\tstatic bool AreBoardsEqual(const char board1[BOARD_SIZE][BOARD_SIZE], const char board2[BOARD_SIZE][BOARD_SIZE]) noexcept;\n\tstatic bool CanMovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const std::forward_list<std::string> &all_moves) noexcept;\n\tBot& GetCurrentPlayer() noexcept;\n\tBot GetCurrentPlayerConst() const noexcept;\n\tBot& GetOtherPlayer() noexcept;\n\tBot GetOtherPlayerConst() const noexcept;\n\tvoid ChangeTurn() noexcept;\n\tvoid AppendToAllGameMoves(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tvoid Reset() noexcept;\n\tvoid CheckCoordinates(const short &x, const short &y, const std::string &func_name) const noexcept(false);\n\tbool EndGameText(const unsigned short &n, const Endgame &end_game) const noexcept;\n\tshort GetEnPassant(const short &x, const short &y) const noexcept;\n\ttemplate<class Iterator> short GetEnPassant(const char board[BOARD_SIZE][BOARD_SIZE], const Iterator &it) const noexcept;\n\tbool ThreefoldRepetition() const noexcept;\n\tbool IsCheck(const bool &turn) const noexcept;\n\tbool IsCheck(std::string &move) noexcept;\n\tstd::forward_list<std::string> PawnMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> RookMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> KnightMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> BishopMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> QueenMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> KingMoves(const short &x, const short &y) const noexcept;\n\tstd::string GetRandomMove() noexcept;\n\tvoid ManuallyPromotePawn(const short &x, const short &y) noexcept;\n\tvoid UpdateBoard(const short &x, const short &y) const noexcept;\n\tvoid UpdateScore(const Bot &p) const noexcept;\n\tfloat EvaluatePosition(const short &x, const short &y) const noexcept;\n\tvoid PrintAllMovesMadeInOrder() const noexcept;\n\t\npublic:\n    bool CheckEndgame(const unsigned short &n = 0) noexcept;\n\tChess(const std::string &player1, const unsigned short &difficulty1, const std::string &player2, const unsigned short &difficulty2) noexcept;\n\tstatic void ChangeToRealCoordinates(char &x1, char &y1, char &x2, char &y2) noexcept;\n\tchar GetPiece(const short &x, const short &y) const noexcept;\n\tbool GetTurn() const noexcept;\n\tstd::forward_list<std::string> AllMoves() noexcept;\n\tvoid MovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const bool &manual_promotion, const bool &update_board) noexcept;\n\tvoid MovePieceBack(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tfloat EvaluateBoard(const bool &turn) const noexcept;\n\tvoid PrintBoard() const noexcept;\n\tbool PlayersTurn(std::string s1,std::string s2) noexcept;\n\tbool BotsTurn(std::string &s1, std::string &s2) noexcept;\n\tbool GameOver() noexcept;\n    std::string GetWinner();\n};\n\n// other function declarations\n\nstd::string ToLowerString(std::string s) noexcept;\ntemplate<class T> T GetRandomNumber(const T &min, const T &max) noexcept;\n\t//CHESS_H\n\n\n// function definitions\n\n// moves the cursor to a different (x, y) location on the terminal\n\n\n// returns the given string in lowercase\nstd::string ToLowerString(std::string s) noexcept {\n\ttransform(s.begin(), s.end(), s.begin(), [](const unsigned char &c){ return tolower(c); });\n\treturn s;\n}\n\n// returns a random number between \"min\" and \"max\"\ntemplate<class T> T GetRandomNumber(const T &min, const T &max) noexcept {\n\treturn min + T(static_cast<double>(rand()) / static_cast<double>(RAND_MAX+1.0) * (max-min+1));\n}\n\n\n\n// chess class implementation\n std::string Chess::GetWinner(){\n    return this->GetOtherPlayerConst().GetName();\n }\n// constructor of chess class\nChess::Chess(const std::string &player1, const unsigned short &difficulty1, const std::string &player2, const unsigned short &difficulty2) noexcept\n: white(player1, difficulty1), black(player2, difficulty2) {\n\tCopyBoard(STARTING_BOARD, board);\n}\n\n// checks whether the given coordinate is within board boundaries or not\nbool Chess::WithinBounds(const short &coord) noexcept {\n\treturn coord>=0 && coord<BOARD_SIZE;\n}\n\n// changes the given board coordinates from ASCII to numerical, e.g. ('d', '3') -> (3, 5)\nvoid Chess::ChangeToRealCoordinates(char &x1, char &y1, char &x2, char &y2) noexcept {\n\tx1 -= 'a', x2 -= 'a';\n\ty1 = '8'-y1, y2 = '8'-y2;\n}\n\n// changes the given board coordinates from numerical to ASCII, e.g. (3, 5) -> ('d', '3')\nvoid Chess::ChangeToString(char &x1, char &y1, char &x2, char &y2) noexcept {\n\tx1 += 'a', x2 += 'a';\n\ty1 = '8'-y1, y2 = '8'-y2;\n}\n\n// returns the given numerical board coordinates as a string\nstd::string Chess::ToString(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\treturn {static_cast<char>(x1+'a'), static_cast<char>('8'-y1), static_cast<char>(x2+'a'), static_cast<char>('8'-y2)};\n}\n\n// returns the name that is displayed on the terminal for the given piece\nstd::string Chess::PieceNameToString(const char &piece) noexcept {\n\tswitch(piece) {\n\t\tcase W_PAWN:\treturn \"W_PAWN\";\n\t\tcase B_PAWN:\treturn \"B_PAWN\";\n\t\tcase W_ROOK:\treturn \"W_ROOK\";\n\t\tcase B_ROOK:\treturn \"B_ROOK\";\n\t\tcase W_KNIGHT:\treturn \"W_KNIGHT\";\n\t\tcase B_KNIGHT:\treturn \"B_KNIGHT\";\n\t\tcase W_BISHOP:\treturn \"W_BISHOP\";\n\t\tcase B_BISHOP:\treturn \"B_BISHOP\";\n\t\tcase W_QUEEN:\treturn \"W_QUEEN\";\n\t\tcase B_QUEEN:\treturn \"B_QUEEN\";\n\t\tcase W_KING:\treturn \"W_KING\";\n\t\tcase B_KING:\treturn \"B_KING\";\n\t\tdefault:\t\treturn \"\";\n\t}\n}\n\n// returns the worth of the given piece in terms of points\nfloat Chess::EvaluatePiece(const char &piece) noexcept {\n\tswitch(piece) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\treturn 10;\t\t// pawn: 10 points\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\treturn 50;\t\t// rook: 50 points\n\t\tcase W_KNIGHT:\n\t\tcase B_KNIGHT:\n\t\tcase W_BISHOP:\n\t\tcase B_BISHOP:\treturn 30;\t\t// knight and bishop: 30 points\n\t\tcase W_QUEEN:\n\t\tcase B_QUEEN:\treturn 90;\t\t// queen: 90 points\n\t\tcase W_KING:\n\t\tcase B_KING:\treturn 900;\t\t// king: 900 points, but you can assume it is infinite\n\t\tdefault:\t\treturn 0;\n\t}\n}\n\n// clears all available moves from the terminal\nvoid Chess::ClearAllMoves(const unsigned short &n) noexcept {\n\n}\n\n// prints the vertical seperators for the game board on the terminal\nvoid Chess::PrintSeparator(const char &ch) noexcept {\n\n}\n\n// copies the board contents of \"from\" to \"to\"\nvoid Chess::CopyBoard(const char from[BOARD_SIZE][BOARD_SIZE], char to[BOARD_SIZE][BOARD_SIZE]) noexcept {\n\tstd::copy(*from, *from + BOARD_SIZE*BOARD_SIZE, *to);\n}\n\n// checks whether the board positions of the given two boards are equal or not\nbool Chess::AreBoardsEqual(const char board1[BOARD_SIZE][BOARD_SIZE], const char board2[BOARD_SIZE][BOARD_SIZE]) noexcept {\n\treturn std::equal(*board1, *board1 + BOARD_SIZE*BOARD_SIZE, *board2);\n}\n\nbool Chess::CanMovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const std::forward_list<std::string> &all_moves) noexcept {\n\treturn std::find(all_moves.cbegin(), all_moves.cend(), ToString(x1, y1, x2, y2)) != all_moves.cend();\n}\n\n// getter method, returns the piece located in the given x and y coordinates\nchar Chess::GetPiece(const short &x, const short &y) const noexcept {\n//\tCheckCoordinates(x, y, \"GetPiece\");\n\treturn board[y][x];\n}\n\n// getter method, returns whether it's team white's turn or not\nbool Chess::GetTurn() const noexcept {\n\treturn whites_turn;\n}\n\n// returns a reference to the player object\nBot& Chess::GetCurrentPlayer() noexcept {\n\treturn whites_turn ? white : black;\n}\n\n// returns a copy of the player object\nBot Chess::GetCurrentPlayerConst() const noexcept {\n\treturn whites_turn ? white : black;\n}\n\n// returns a reference to the player object\nBot& Chess::GetOtherPlayer() noexcept {\n\treturn whites_turn ? black : white;\n}\n\n// returns a copy of the player object\nBot Chess::GetOtherPlayerConst() const noexcept {\n\treturn whites_turn ? black : white;\n}\n\n// changes whose turn it is so the other player can make its move\nvoid Chess::ChangeTurn() noexcept {\n\twhites_turn = !whites_turn;\n}\n\n// appends the last made game move to \"all_game_moves\" list\nvoid Chess::AppendToAllGameMoves(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\tif(GetCurrentPlayerConst().GetCastling() && (board[y1][x1] == B_KING + 7*whites_turn) && (x2 == 2 || x2 == 6))\n\t\tall_game_moves.emplace_back(CASTLING, std::string(1, x2));\n\telse\n\t\tall_game_moves.emplace_back(NORMAL, ToString(x1, y1, x2, y2) + board[y1][x1] + board[y2][x2]);\n}\n\n// resets the game, everything is back to its default value\nvoid Chess::Reset() noexcept {\n\tCopyBoard(STARTING_BOARD, board);\n\twhite.Reset();\n\tblack.Reset();\n\tall_game_moves.clear();\n\twhites_turn = true;\n\tmoves_after_last_pawn_move_or_capture = 0;\n\tsystem(\"cls\");\n}\n\n// a function for exception handling, checks whether the given coordinates is within board boundaries or not\nvoid Chess::CheckCoordinates(const short &x, const short &y, const std::string &func_name) const noexcept(false) {\n\ttry {\n\t\tif(!WithinBounds(x))\t\tthrow x;\n\t\tif(!WithinBounds(y))\t\tthrow y;\n\t}\n\tcatch(const short &coord) {\n\t\tstd::cerr << std::endl << std::endl << TO_RIGHT << \"!ERROR!\\t\\tInvalid coordinate: '\" << coord << \"'.\\t\\t!ERROR!\";\n\t\tstd::cerr << std::endl << TO_RIGHT << \"      \\t\\tException occurred in \\\"\" << func_name << \"\\\".\";\n\t\tPrintAllMovesMadeInOrder();\n\t\texit(1);\n\t}\n}\n\n// prints game over message to the terminal\nbool Chess::EndGameText(const unsigned short &n, const Endgame &end_game) const noexcept {\n\tClearAllMoves(n);\n\n\tswitch(end_game) {\n\t\tcase CHECKMATE:\n\t\t\t\n\t\t\treturn true;\n\t\tdefault:\n\t\t\t//Draw!!!\n\t\t\tswitch(end_game) {\n\t\t\t\tcase FIFTY_MOVES:\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\tcase THREEFOLD_REP:\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t}\n}\n\n// returns the x coordinate of the eaten pawn piece\nshort Chess::GetEnPassant(const short &x, const short &y) const noexcept {\n\tif(all_game_moves.empty())\n\t\treturn -1;\n\tif(all_game_moves.back().first != NORMAL)\n\t\treturn -1;\n\tauto last_move = all_game_moves.back().second;\n\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\treturn ((last_move[4] == W_PAWN - 7*whites_turn) && (abs(last_move[0] - x) == 1) && (last_move[3]-last_move[1] == 2*(whites_turn ? 1 : -1)) && (y == 4 - whites_turn)) ? last_move[0] : -1;\n}\n\n// returns the x coordinate of the en passant move\ntemplate<class Iterator> short Chess::GetEnPassant(const char board[BOARD_SIZE][BOARD_SIZE], const Iterator &it) const noexcept {\n\tif(it->first != NORMAL)\n\t\treturn -1;\n\tauto last_move = it->second;\n\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\tfor(short x=0;x<BOARD_SIZE;++x)\n\t\tif(board[3 + whites_turn][x] == W_PAWN - 7*whites_turn)\n\t\t\tif((last_move[4] == B_PAWN + 7*whites_turn) && (abs(last_move[0] - x) == 1) && (last_move[3] - last_move[1] == 2*(whites_turn ? -1 : 1)))\n\t\t\t\treturn last_move[0];\n\treturn -1;\n}\n\n// returns true if threefold repetition occurs, false otherwise\nbool Chess::ThreefoldRepetition() const noexcept {\n\tstatic char prev_board[BOARD_SIZE][BOARD_SIZE];\n\tCopyBoard(board, prev_board);\n\tunsigned short position_count = 1;\n\tauto it = all_game_moves.crbegin();\n\tauto last_move = it->second;\n\twhile(true) {\n\t\tfor(unsigned short i=0;i<2;++i)\t{\n\t\t\tswitch(it->first) {\n\t\t\t\tcase CASTLING:\n\t\t\t\t\treturn false;\t\t// if a pawn has moved or a castling/capture has occured, then that board position is unique and repetition is not possible\n\t\t\t\tdefault:\n\t\t\t\t\tif(last_move[4] == W_PAWN || last_move[4] == B_PAWN || last_move[5] != EMPTY)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\t\t\t\t\tprev_board[short(last_move[1])][short(last_move[0])] = last_move[4], prev_board[short(last_move[3])][short(last_move[2])] = EMPTY;\n\t\t\t\t\tif(it->first == EN_PASSANT)\n\t\t\t\t\t\tprev_board[short(last_move[1])][short(last_move[2])] = i == whites_turn ? B_PAWN : W_PAWN;\n\t\t\t}\n\t\t\tif((++it) == all_game_moves.crend())\n\t\t\t\treturn false;\n\t\t\tlast_move = it->second;\n\t\t}\n\t\tif(AreBoardsEqual(prev_board, board))\t\t// check for castling and en passant in every 2 turns\n\t\t\tif(GetOtherPlayerConst().GetCastling() == (it->first == CASTLING ? false : last_move[6 + (it->first == PROMOTION)]))\n\t\t\t\tif((all_game_moves.size() > 1 ? GetEnPassant(board, prev(all_game_moves.cend(), 2)) : -1)\n\t\t\t\t== (next(it) == all_game_moves.crend() ? -1 : GetEnPassant(prev_board, next(it))))\n\t\t\t\t\tif((++position_count) == 3)\n\t\t\t\t\t\treturn true;\n\t}\n}\n\n// returns true if the player's king is in check, false otherwise\nbool Chess::IsCheck(const bool &turn) const noexcept {\n\tshort x = -1, y = -1;\n\tfor(short i=0;x==-1;++i)\n\t\tfor(short j=0;j<BOARD_SIZE;++j)\n\t\t\tif(board[j][i] == B_KING + 7*turn) {\n\t\t\t\tx = i, y = j;\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(short i=x+1;i<BOARD_SIZE;++i)\t\t\t\t\t\t// check queen and rook\n\t\tif(board[y][i] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[y][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[y][i] != EMPTY)\tbreak;\n\tfor(short i=x-1;i>=0;--i)\n\t\tif(board[y][i] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[y][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[y][i] != EMPTY)\tbreak;\n\tfor(short i=y+1;i<BOARD_SIZE;++i)\n\t\tif(board[i][x] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[i][x] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[i][x] != EMPTY)\tbreak;\n\tfor(short i=y-1;i>=0;--i)\n\t\tif(board[i][x] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[i][x] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[i][x] != EMPTY)\tbreak;\n\tfor(short i=x-1, j=y-1; i>=0 && j>=0; --i, --j)\t\t\t// check queen and bishop\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x-1, j=y+1; i>=0 && j<BOARD_SIZE; --i, ++j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x+1, j=y-1; i<BOARD_SIZE && j>=0; ++i, --j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x+1, j=y+1; i<BOARD_SIZE && j<BOARD_SIZE; ++i, ++j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x-1;i<x+2;++i)\t\t\t\t\t\t\t\t// check king\n\t\tfor(short j=y-1;j<y+2;++j)\n\t\t\tif((board[j][i] == W_KING - 7*turn) && WithinBounds(i) && WithinBounds(j))\t\t\treturn true;\n\tif((board[y-1][x-2] == W_KNIGHT - 7*turn) && (y > 0) && (x > 1))\t\t\t\t\t\t\treturn true;\t// check knight\n\telse if((board[y-1][x+2] == W_KNIGHT - 7*turn) && (y > 0) && (x < BOARD_SIZE-2))\t\t\treturn true;\n\telse if((board[y+1][x-2] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-1) && (x > 1))\t\t\treturn true;\n\telse if((board[y+1][x+2] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-1) && (x < BOARD_SIZE-2))\treturn true;\n\telse if((board[y-2][x-1] == W_KNIGHT - 7*turn) && (y > 1) && (x > 0))\t\t\t\t\t\treturn true;\n\telse if((board[y-2][x+1] == W_KNIGHT - 7*turn) && (y > 1) && (x < BOARD_SIZE-1))\t\t\treturn true;\n\telse if((board[y+2][x-1] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-2) && (x > 0))\t\t\treturn true;\n\telse if((board[y+2][x+1] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-2) && (x < BOARD_SIZE-1))\treturn true;\n\telse if((board[y + (turn ? -1 : 1)][x+1] == W_PAWN - 7*turn) && (x < BOARD_SIZE-1))\t\t\treturn true;\t// check pawn\n\telse if((board[y + (turn ? -1 : 1)][x-1] == W_PAWN - 7*turn) && (x > 0))\t\t\t\t\treturn true;\n\treturn false;\n}\n\n// function overload, returns true if the player's king is in check, false otherwise\nbool Chess::IsCheck(std::string &move) noexcept {\n\tChangeToRealCoordinates(move[0], move[1], move[2], move[3]);\n\tMovePiece(move[0], move[1], move[2], move[3], false, false);\n\tconst bool &is_check = IsCheck(!whites_turn);\n\tMovePieceBack(move[0], move[1], move[2], move[3]);\n\tChangeToString(move[0], move[1], move[2], move[3]);\n\treturn is_check;\n}\n\n// returns a list of all possible moves the pawn located in (x, y) can make\nstd::forward_list<std::string> Chess::PawnMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tconst short &inc = whites_turn ? -1 : 1;\n\tstd::forward_list<std::string> all_moves;\n\tif(board[y+inc][x] == EMPTY) {\n\t\tall_moves.emplace_front(ToString(x, y, x, y+inc));\t\t\t\t// 1 square forward\n\t\tif((y == 1 + 5*whites_turn) && (board[y + 2*inc][x] == EMPTY))\n\t\t\tall_moves.emplace_front(ToString(x, y, x, y + 2*inc));\t\t// 2 squares forward\n\t}\n\tif(GetEnPassant(x, y) != -1)\n\t\tall_moves.emplace_front(ToString(x, y, GetEnPassant(x, y), y+inc));\n\tif(IsValid(board[y+inc][x+1]) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y+inc));\t\t// diagonal attack moves\n\tif(IsValid(board[y+inc][x-1]) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y+inc));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the rook located in (x, y) can make\nstd::forward_list<std::string> Chess::RookMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x+1;i<BOARD_SIZE;++i)\t\t\t// right\n\t\tif(board[y][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\telse {\n\t\t\tif(IsValid(board[y][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x-1;i>=0;--i)\t\t\t\t\t// left\n\t\tif(board[y][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\telse {\n\t\t\tif(IsValid(board[y][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=y+1;i<BOARD_SIZE;++i)\t\t\t// down\n\t\tif(board[i][x] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\telse {\n\t\t\tif(IsValid(board[i][x]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=y-1;i>=0;--i)\t\t\t\t\t// up\n\t\tif(board[i][x] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\telse {\n\t\t\tif(IsValid(board[i][x]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\t\tbreak;\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the knight located in (x, y) can make\nstd::forward_list<std::string> Chess::KnightMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch <= 0; } : [](const char &ch){ return ch >= 0; };\n\tstd::forward_list<std::string> all_moves;\n\tif(IsValid(board[y-1][x-2]) && (y > 0) && (x > 1))\n\t\tall_moves.emplace_front(ToString(x, y, x-2, y-1));\n\tif(IsValid(board[y-1][x+2]) && (y > 0) && (x < BOARD_SIZE-2))\n\t\tall_moves.emplace_front(ToString(x, y, x+2, y-1));\n\tif(IsValid(board[y+1][x-2]) && (y < BOARD_SIZE-1) && (x > 1))\n\t\tall_moves.emplace_front(ToString(x, y, x-2, y+1));\n\tif(IsValid(board[y+1][x+2]) && (y < BOARD_SIZE-1) && (x < BOARD_SIZE-2))\n\t\tall_moves.emplace_front(ToString(x, y, x+2, y+1));\n\tif(IsValid(board[y-2][x-1]) && (y > 1) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y-2));\n\tif(IsValid(board[y-2][x+1]) && (y > 1) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y-2));\n\tif(IsValid(board[y+2][x-1]) && (y < BOARD_SIZE-2) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y+2));\n\tif(IsValid(board[y+2][x+1]) && (y < BOARD_SIZE-2) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y+2));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the bishop located in (x, y) can make\nstd::forward_list<std::string> Chess::BishopMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x-1, j=y-1; i>=0 && j>=0; --i, --j)\t\t\t\t\t\t// upper left diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x-1, j=y+1; i>=0 && j<BOARD_SIZE; --i, ++j)\t\t\t\t// lower left diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x+1, j=y-1; i<BOARD_SIZE && j>=0; ++i, --j)\t\t\t\t// upper right diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x+1, j=y+1; i<BOARD_SIZE && j<BOARD_SIZE; ++i, ++j)\t\t// lower right diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the queen located in (x, y) can make\nstd::forward_list<std::string> Chess::QueenMoves(const short &x, const short &y) const noexcept {\n\tauto all_moves = RookMoves(x, y);\t\t\t// queen = rook + bishop\n\tall_moves.merge(BishopMoves(x, y));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the king located in (x, y) can make\nstd::forward_list<std::string> Chess::KingMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch <= 0; } : [](const char &ch){ return ch >= 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x-1;i<x+2;++i)\t\t// add moves within 1 square reach\n\t\tfor(short j=y-1;j<y+2;++j)\n\t\t\tif(IsValid(board[j][i]) && WithinBounds(i) && WithinBounds(j))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\tif(GetCurrentPlayerConst().GetCastling())\t\t// add castling moves if castling is possible\n\t\tif(!IsCheck(whites_turn)) {\n\t\t\tconst short &line = (BOARD_SIZE-1)*whites_turn;\n\t\t\tif((board[line][0] == B_ROOK + 7*whites_turn) && board[line][1] == EMPTY && board[line][2] == EMPTY && board[line][3] == EMPTY)\n\t\t\t\tall_moves.emplace_front(ToString(4, line, 2, line));\t// long castling\n\t\t\telse if((board[line][7] == B_ROOK + 7*whites_turn) && board[line][5] == EMPTY && board[line][6] == EMPTY)\n\t\t\t\tall_moves.emplace_front(ToString(4, line, 6, line));\t// short castling\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the player can make\nstd::forward_list<std::string> Chess::AllMoves() noexcept {\n\tstd::forward_list<std::string> all_moves;\n\tfor(short y=0;y<BOARD_SIZE;++y)\n\t\tfor(short x=0;x<BOARD_SIZE;++x) {\n\t\t\tif((board[y][x] < 0) == whites_turn)\n\t\t\t\tcontinue;\n\t\t\tswitch(board[y][x]) {\n\t\t\t\tcase W_PAWN:\n\t\t\t\tcase B_PAWN:\n\t\t\t\t\tall_moves.merge(PawnMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_ROOK:\n\t\t\t\tcase B_ROOK:\n\t\t\t\t\tall_moves.merge(RookMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_KNIGHT:\n\t\t\t\tcase B_KNIGHT:\n\t\t\t\t\tall_moves.merge(KnightMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_BISHOP:\n\t\t\t\tcase B_BISHOP:\n\t\t\t\t\tall_moves.merge(BishopMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_QUEEN:\n\t\t\t\tcase B_QUEEN:\n\t\t\t\t\tall_moves.merge(QueenMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_KING:\n\t\t\t\tcase B_KING:\n\t\t\t\t\tall_moves.merge(KingMoves(x, y));\n\t\t\t}\n\t\t}\n\tfor(auto it = all_moves.begin(), prev = all_moves.before_begin(); it != all_moves.cend();)\t\t// if the possible move makes me checkmate after the opponent's turn, remove it from the list\n\t\tif(IsCheck(*it))\n\t\t\tit = all_moves.erase_after(prev);\n\t\telse\n\t\t\t++it, ++prev;\n\treturn all_moves;\n}\n\n// returns a random move the player can make\nstd::string Chess::GetRandomMove() noexcept {\n\tauto all_moves = AllMoves();\n\tauto move = all_moves.begin();\n\tadvance(move, GetRandomNumber<unsigned short>(0, distance(all_moves.cbegin(), all_moves.cend()) - 1));\n\tChangeToRealCoordinates((*move)[0], (*move)[1], (*move)[2], (*move)[3]);\n\treturn *move;\n}\n\n// asks the player it's choice of promotion, then promotes the pawn to the desired piece\nvoid Chess::ManuallyPromotePawn(const short &x, const short &y) noexcept {\n\t\n\tchar key = 'q';\n\n\t\tswitch(key = tolower(key)) {\n\t\t\tcase 'r':\tboard[y][x] = whites_turn ? W_ROOK : B_ROOK;\t\treturn;\n\t\t\tcase 'k':\tboard[y][x] = whites_turn ? W_KNIGHT : B_KNIGHT;\treturn;\n\t\t\tcase 'b':\tboard[y][x] = whites_turn ? W_BISHOP : B_BISHOP;\treturn;\n\t\t\tcase 'q':\tboard[y][x] = whites_turn ? W_QUEEN : B_QUEEN;\t\treturn;\n\t\t\n\t\t}\n}\n\n// moves the piece from (x1, y1) to (x2, y2)\nvoid Chess::MovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const bool &manual_promotion, const bool &update_board) noexcept {\n//\tCheckCoordinates(x1, y1, \"MovePiece\");\n//\tCheckCoordinates(x2, y2, \"MovePiece\");\n\tAppendToAllGameMoves(x1, y1, x2, y2);\t\t// similar to FEN notation but not really, the starting and ending points of the moving piece, promoted piece if there is promotion and ability to do castling\n\tswitch(board[y1][x1]) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\n\t\t\tif(y2 == ((BOARD_SIZE-1) * !whites_turn)) {\t\t\t// check for castling, promotion or en passant\n\t\t\t\tif(manual_promotion) {\n\t\t\t\t\tManuallyPromotePawn(x1, y1);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(whites_turn ? WHITE_BOT_RANDOM : BLACK_BOT_RANDOM)\n\t\t\t\t\tboard[y1][x1] = (whites_turn ? 1 : -1) * GetRandomNumber(2, 5);\n\t\t\t\telse\n\t\t\t\t\tboard[y1][x1] = whites_turn ? W_QUEEN : B_QUEEN;\n\t\t\t\tall_game_moves.back().first = PROMOTION;\n\t\t\t\tall_game_moves.back().second.push_back(board[y1][x1]);\n\t\t\t}\n\t\t\telse if(x1 != x2 && board[y2][x2] == EMPTY) {\n\t\t\t\tboard[y1][x2] = EMPTY;\n\t\t\t\tif(update_board) {\n\t\t\t\t\tGetCurrentPlayer().IncreaseScore(EvaluatePiece(W_PAWN));\n\t\t\t\t\tUpdateScore(GetCurrentPlayerConst());\n\t\t\t\t\tUpdateBoard(x2, y1);\n\t\t\t\t}\n\t\t\t\tall_game_moves.back().first = EN_PASSANT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase W_KING:\n\t\tcase B_KING:\n\t\t\tif(GetCurrentPlayerConst().GetCastling()) {\n\t\t\t\tconst short &line = (BOARD_SIZE-1) * whites_turn;\n\t\t\t\tswitch(x2) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tboard[line][3] = board[line][0], board[line][0] = EMPTY;\n\t\t\t\t\t\tif(update_board) {\n\t\t\t\t\t\t\tUpdateBoard(0, line);\n\t\t\t\t\t\t\tUpdateBoard(3, line);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tboard[line][5] = board[line][7], board[line][7] = EMPTY;\n\t\t\t\t\t\tif(update_board) {\n\t\t\t\t\t\t\tUpdateBoard(7, line);\n\t\t\t\t\t\t\tUpdateBoard(5, line);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\n\t\t\tGetCurrentPlayer().SetCastling(false);\n\t}\n\tif(all_game_moves.back().first != CASTLING)\t\t\t\tall_game_moves.back().second.push_back(GetCurrentPlayerConst().GetCastling());\n\tboard[y2][x2] = board[y1][x1], board[y1][x1] = EMPTY;\n\tif(update_board) {\n\t\tif(all_game_moves.back().first != CASTLING)\n\t\t\tif(all_game_moves.back().second[5] != EMPTY) {\n\t\t\t\tGetCurrentPlayer().IncreaseScore(EvaluatePiece(all_game_moves.back().second[5]));\n\t\t\t\tUpdateScore(GetCurrentPlayerConst());\n\t\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// the piece is eaten\n\t\t\t}\n\t\tUpdateBoard(x1, y1);\n\t\tUpdateBoard(x2, y2);\n\t}\n\tChangeTurn();\t\t// it's the opponent's turn\n}\n\n// undoes the move from (x1,y1) to (x2,y2), the opposite of the \"MovePiece\" function\nvoid Chess::MovePieceBack(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\tChangeTurn();\n\tboard[y1][x1] = board[y2][x2], board[y2][x2] = all_game_moves.back().first == CASTLING ? static_cast<char>(EMPTY) : all_game_moves.back().second[5];\n\tswitch(board[y1][x1]) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\n\t\t\tif(x1 != x2 && board[y2][x2] == EMPTY)\n\t\t\t\tboard[y1][x2] = whites_turn ? B_PAWN : W_PAWN;\n\t\t\tbreak;\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\n\t\t\tif(prev(all_game_moves.cend(), 3)->first != CASTLING)\n\t\t\t\tif(prev(all_game_moves.cend(), 3)->second[6 + (prev(all_game_moves.cend(), 3)->first == PROMOTION)])\n\t\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t\t\tbreak;\n\t\tcase W_QUEEN:\n\t\tcase B_QUEEN:\n\t\t\tif(all_game_moves.back().first == PROMOTION)\n\t\t\t\tboard[y1][x1] = whites_turn ? W_PAWN : B_PAWN;\n\t\t\tbreak;\n\t\tcase W_KING:\n\t\tcase B_KING:\n\t\t\tif(all_game_moves.back().first == CASTLING) {\n\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t\t\t\tconst short line = (BOARD_SIZE-1) * whites_turn;\n\t\t\t\tswitch(x2) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tboard[line][0] = board[line][3], board[line][3] = EMPTY;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tboard[line][7] = board[line][5], board[line][5] = EMPTY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(prev(all_game_moves.cend(), 3)->first != CASTLING)\n\t\t\t\tif(prev(all_game_moves.cend(), 3)->second[6 + (prev(all_game_moves.cend(), 3)->first == PROMOTION)])\n\t\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t}\n\tall_game_moves.pop_back();\n}\n\n// updates the board display on the terminal\nvoid Chess::UpdateBoard(const short &x, const short &y) const noexcept {\n\tconst unsigned short &diff = BOX_WIDTH - PieceNameToString(board[y][x]).length();\n\t\n}\n\n// updates the score display on the terminal\nvoid Chess::UpdateScore(const Bot &p) const noexcept {\n\tconst unsigned short &dx = p==white ? white.GetName().length() + 2 : (BOX_WIDTH+1)*BOARD_SIZE - 5;\n\t\n\n}\n\n// returns the worth of the position of the piece in terms of points\nfloat Chess::EvaluatePosition(const short &x, const short &y) const noexcept {\n\tif(board[y][x] == EMPTY)\n\t\treturn 0;\n\tstatic float PIECE_POS_POINTS[6][BOARD_SIZE][BOARD_SIZE] =\n\t{{{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\t\t// king\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-2.0, -3.0, -3.0, -4.0, -4.0, -3.0, -3.0, -2.0},\n\t{-1.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -1.0},\n\t{2.0, 2.0, 0.0, 0.0, 0.0, 0.0, 2.0, 2.0},\n\t{2.0, 3.0, 1.0, 0.0, 0.0, 1.0, 3.0, 2.0}}\n\t,\n\t{{-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0},\t\t// queen\n\t{-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0},\n\t{-0.5, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5},\n\t{0.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5},\n\t{-1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0}}\n\t,\n\t{{-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0},\t\t// bishop\n\t{-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 1.0, 1.0, 0.5, 0.0, -1.0},\n\t{-1.0, 0.5, 0.5, 1.0, 1.0, 0.5, 0.5, -1.0},\n\t{-1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, -1.0},\n\t{-1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0},\n\t{-1.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, -1.0},\n\t{-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0}}\n\t,\n\t{{-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0},\t\t// knight\n\t{-4.0, -2.0, 0.0, 0.0, 0.0, 0.0, -2.0, -4.0},\n\t{-3.0, 0.0, 1.0, 1.5, 1.5, 1.0, 0.0, -3.0},\n\t{-3.0, 0.5, 1.5, 2.0, 2.0, 1.5, 0.5, -3.0},\n\t{-3.0, 0.0, 1.5, 2.0, 2.0, 1.5, 0.0, -3.0},\n\t{-3.0, 0.5, 1.0, 1.5, 1.5, 1.0, 0.5, -3.0},\n\t{-4.0, -2.0, 0.0, 0.5, 0.5, 0.0, -2.0, -4.0},\n\t{-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0}}\n\t,\n\t{{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\t\t\t\t// rook\n\t{0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0}}\n\t,\n\t{{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\t\t\t\t// pawn\n\t{5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0},\n\t{1.0, 1.0, 2.0, 3.0, 3.0, 2.0, 1.0, 1.0},\n\t{0.5, 0.5, 1.0, 2.5, 2.5, 1.0, 0.5, 0.5},\n\t{0.0, 0.0, 0.0, 2.0, 2.0, 0.0, 0.0, 0.0},\n\t{0.5, -0.5, -1.0, 0.0, 0.0, -1.0, -0.5, 0.5},\n\t{0.5, 1.0, 1.0, -2.0, -2.0, 1.0, 1.0, 0.5},\n\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}}};\t\t\t\t// returns negative points if the pieces are black, positive points if the pieces are white\n\treturn (board[y][x]<0 ? -1 : 1) * (EvaluatePiece(board[y][x]) + PIECE_POS_POINTS[board[y][x] + 7*(board[y][x]<0) - 1][board[y][x]<0 ? BOARD_SIZE-y-1 : y][x]);\n}\n\n// returns the worth of the board position in terms of points\nfloat Chess::EvaluateBoard(const bool &turn) const noexcept {\n\tfloat total_evaluation = 0.0;\n\tfor(short y=0;y<BOARD_SIZE;++y)\n\t\tfor(short x=0;x<BOARD_SIZE;++x)\n\t\t\ttotal_evaluation += EvaluatePosition(x, y);\n\treturn (turn ? 1 : -1) * total_evaluation;\n}\n\n// prints the game board on the terminal\nvoid Chess::PrintBoard() const noexcept {\n\tstd::cout << TO_DOWN << TO_RIGHT;\n\tfor(short y=0;y<BOARD_SIZE;++y) {\n\t\tPrintSeparator(' ');\n\t\tstd::cout << \"\\b\\b\\b\" << BOARD_SIZE-y << \"  \";\n\t\tfor(short x=0;x<BOARD_SIZE;++x) {\n\t\t\tconst unsigned short &diff = BOX_WIDTH - PieceNameToString(board[y][x]).length();\n\t\t\tstd::cout << std::string(diff/2, ' ') << PieceNameToString(board[y][x]) << std::string(diff/2, ' ');\n\t\t\tif(diff%2)\t\t\t\tstd::cout << \" \";\n\t\t\tif(x < BOARD_SIZE-1)\tstd::cout << \"|\";\n\t\t}\n\t\tif(y < BOARD_SIZE-1) {\n\t\t\tstd::cout << std::endl << TO_RIGHT;\n\t\t\tPrintSeparator('_');\n\t\t}\n\t}\n\tstd::cout << std::endl << TO_RIGHT;\n\tPrintSeparator(' ');\n\tfor(char ch='a';ch<'a'+BOARD_SIZE;++ch)\n\t\tstd::cout << std::string(BOX_WIDTH/2, ' ') << ch << std::string(BOX_WIDTH/2, ' ');\n\tstd::cout << std::endl << std::endl << TO_RIGHT << white.GetName() << \": 0\";\n\tstd::cout << std::string((BOX_WIDTH+1)*BOARD_SIZE - white.GetName().length() - black.GetName().length() - 10, ' ') << black.GetName() << \": 0\";\n\tstd::cout << std::endl << std::endl << TO_RIGHT << white.GetName() << \"'s turn...\";\n\tstd::cout << std::endl << TO_RIGHT << \"Enter move coordinates (x1,y1)->(x2,y2):\";\n\tstd::cout << std::endl << std::endl << TO_RIGHT << \"All possible moves:\" << std::endl;\n}\n\n// after the game is over, prints all moves played throughout the game in chronological order\nvoid Chess::PrintAllMovesMadeInOrder() const noexcept {\n\tstd::cout << std::endl << std::endl << TO_RIGHT << \"All moves made in order:\" << std::endl;\n\tbool turn = true;\n\tfor(const auto &game_move : all_game_moves) {\n\t\tstd::cout << std::endl << TO_RIGHT << (turn ? white : black).GetName() << \": \";\n\t\tswitch(game_move.first) {\n\t\t\tcase CASTLING:\n\t\t\t\tstd::cout << \"castling \" << (game_move.second[0] == 2 ? \"long\" : \"short\");\tbreak;\n\t\t\tdefault:\n\t\t\t\tstd::cout << ToLowerString(PieceNameToString(game_move.second[4])).substr(2) << \" '\" << game_move.second.substr(0, 2) << \"' to \";\n\t\t\t\tif(game_move.second[5] != EMPTY)\n\t\t\t\t\tstd::cout << ToLowerString(PieceNameToString(game_move.second[5])).substr(2) + \" \";\n\t\t\t\tstd::cout << \"'\" << game_move.second.substr(2, 2) << \"'\";\n\t\t\t\tswitch(game_move.first) {\n\t\t\t\t\tcase PROMOTION:\n\t\t\t\t\t\tstd::cout << \" promoted to \" << ToLowerString(PieceNameToString(game_move.second[6])).substr(2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EN_PASSANT:\n\t\t\t\t\t\tstd::cout << \" (en passant)\";\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tturn = !turn;\n\t}\n}\n\n// checks if the game is over or not\nbool Chess::CheckEndgame(const unsigned short &n) noexcept {\n\tif(AllMoves().empty()) {\t\t\t// if the opponent has no moves left, then it is checkmate\n\t\tGetOtherPlayer().IncreaseScore(EvaluatePiece(W_KING));\n\t\tUpdateScore(GetOtherPlayerConst());\n\t\treturn EndGameText(n, CHECKMATE);\n\t}\n\telse if(all_game_moves.back().first != CASTLING) {\n\t\tif(all_game_moves.back().second[4] == W_PAWN - 7*whites_turn)\n\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// pawn has moved\n\t\telse if(all_game_moves.back().second[5] != EMPTY)\n\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// capture has occured\n\t\telse if((++moves_after_last_pawn_move_or_capture) == 50)\n\t\t\treturn EndGameText(n, FIFTY_MOVES);\n\t}\n\telse if((++moves_after_last_pawn_move_or_capture) == 50)\n\t\treturn EndGameText(n, FIFTY_MOVES);\n\tif(ThreefoldRepetition())\n\t\treturn EndGameText(n, THREEFOLD_REP);\n\treturn false;\n}\n\n// lists all possible moves, expects player input and plays the given move if it is valid, expects a valid input otherwise\nbool Chess::PlayersTurn(std::string from,std::string to) noexcept {\n\tauto all_moves = AllMoves();\n\tall_moves.sort();\n\tunsigned short i=0;\n\t\n\tif(IsCheck(whites_turn)) {\n\t\t\n\t\ti += 2*MOVES_PER_LINE;\n\t}\n\t\n\twhile(true) {\n\t\t\n\t\t\n\t\tif(!ToLowerString(from).compare(\"quit\"))\n\t\t\treturn EndGameText(i/MOVES_PER_LINE + 1, QUIT);\n\t\tif(!ToLowerString(from).compare(\"exit\"))\n\t\t\treturn EndGameText(i/MOVES_PER_LINE + 1, QUIT);\n\t\t\n\t\tfrom.resize(2);\n\t\tto.resize(2);\n\t\tfrom.shrink_to_fit();\n\t\tto.shrink_to_fit();\n\t\tfrom[0] = tolower(from[0]), to[0] = tolower(to[0]);\n\t\tChangeToRealCoordinates(from[0], from[1], to[0], to[1]);\n       \n\t\tif((from[0]!=to[0] || from[1]!=to[1]) && WithinBounds(from[0]) && WithinBounds(from[1]) && WithinBounds(to[0]) && WithinBounds(to[1])){\n\t\t\tif(CanMovePiece(from[0], from[1], to[0], to[1], all_moves)) {\n\t\t\t\tMovePiece(from[0], from[1], to[0], to[1], true, true);\n\t\t\t\tif(CheckEndgame(i/MOVES_PER_LINE + 1))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\t}else{\n                return false;\n            }\n        }else{\n            return false;\n        }\n\t\t\n\t\t\n\t}\n\t\n\tClearAllMoves(i/MOVES_PER_LINE + 1);\n\t\n\treturn true;\n}\n\n// plays the bots move\nbool Chess::BotsTurn(std::string &s1, std::string &s2) noexcept {\n\tconst auto &move = (whites_turn ? WHITE_BOT_RANDOM : BLACK_BOT_RANDOM) ? GetRandomMove() : GetCurrentPlayer().GetIdealMove(*this);\n\tMovePiece(move[0], move[1], move[2], move[3], false, true);\n\t\n\ts1 = \"  \";\n\ts2 = \"  \";\n\ts1[0] = move[0]+'a';\n\ts1[1] = '8' - move[1];\n\ts2[0] = move[2]+'a';\n\ts2[1] = '8' - move[3];\n\tif(CheckEndgame())\n\t\treturn false;\n\t\n\treturn true;\n}\n\n// prints game over messages and expects user input for another game\nbool Chess::GameOver() noexcept {\n\t//std::cout << std::endl << std::endl << std::endl << TO_RIGHT << \"Press R to play again.\";\n\t//std::cout << std::endl << TO_RIGHT << \"Press any other key to quit.\";\n\t//PrintAllMovesMadeInOrder();\n\tchar key = 'q';\n\tswitch(key = tolower(key)) {\n\t\tcase 'r':\n\t\t\tReset();\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n\n\n\n\n\n// bot class constructor\nBot::Bot(const std::string &name, const unsigned short &difficulty) noexcept : Player(name), difficulty(difficulty) {\t}\n\n// getter method, returns the difficulty level of the bot\nunsigned short Bot::GetDifficulty() const noexcept {\n\treturn difficulty;\n}\n\n// returns the optimal move the bot can make with the default difficulty level (according to alpha-beta pruning at least)\nstd::string Bot::GetIdealMove(Chess &c) noexcept {\n\treturn root.AlphaBetaRoot(c, difficulty);\n}\n\n// function overload, returns the optimal move the bot can make with the given difficulty level\nstd::string Bot::GetIdealMove(Chess &c, unsigned short difficulty) noexcept {\n\treturn root.AlphaBetaRoot(c, difficulty);\n}\n\n// operator overload for '=='\nbool Bot::operator== (const Bot &b) const noexcept {\n\treturn !name.compare(b.name);\t\n}\n\n\n\n\n\n// player class constructor\nPlayer::Player(const std::string &name) noexcept : name(name) {\t}\n\n// getter method which returns the name of the player\nstd::string Player::GetName() const noexcept {\n\treturn name;\n}\n\n// getter method which returns the score of the player\nunsigned short Player::GetScore() const noexcept {\n\treturn score;\n}\n\n// getter method which returns whether the player can castle or not\nbool Player::GetCastling() const noexcept {\n\treturn castling;\n}\n\n// setter method which sets whether the player can castle or not\nvoid Player::SetCastling(const bool &castling) noexcept {\n\tthis->castling = castling;\n}\n\n// increases the score by an amount of \"inc\" points\nvoid Player::IncreaseScore(const unsigned short &inc) noexcept {\n\tscore += inc;\n}\n\n// resets the score and the ability to castle to their initial values\nvoid Player::Reset() noexcept {\n\tscore = 0;\n\tcastling = true;\n}\n\n// operator overload for '=='\nbool Player::operator== (const Player &p) const noexcept {\n\treturn !name.compare(p.name);\n}\n\n\n\n\n\n\n// creates a subtree which contains all possible moves the player can make\nvoid PathNode::CreateSubtree(Chess &c) noexcept {\n\tauto all_moves = c.AllMoves();\t\t\t\t\t// add all possible moves to the Node's map\n\tfor(auto &move : all_moves) {\n\t\tChess::ChangeToRealCoordinates(move[0], move[1], move[2], move[3]);\n\t\tchild_node_list.emplace(move, PathNode());\n\t}\n}\n\n// returns the maximum score for the minimizing player and the minimum score for the maximizing player in each recursion\nfloat PathNode::AlphaBeta(Chess &c, unsigned short &depth, float alpha, float beta, const bool &maximizing_player, const bool &initial_turn) noexcept {\n\tif(!depth)\n\t\treturn c.EvaluateBoard(initial_turn);\n\tCreateSubtree(c);\n\tfloat points = maximizing_player ? -9999 : 9999;\n\tfor(auto &node : child_node_list) {\t\t\t\t\t\t// 1-0: from, 3-2: to\n\t\tif(c.GetPiece(node.first[2], node.first[3]) == W_KING - 7*c.GetTurn()) {\n\t\t\tchild_node_list.clear();\n\t\t\treturn maximizing_player ? 9999 : -9999;\t\t// if my target piece is king, then it is the most rewarding move\n\t\t}\n\t\tc.MovePiece(node.first[0], node.first[1], node.first[2], node.first[3], false, false);\n\t\tpoints = maximizing_player ? std::max(points, node.second.AlphaBeta(c, --depth, alpha, beta, false, initial_turn))\t\t// recursive alpha-beta algorithm\n\t\t: std::min(points, node.second.AlphaBeta(c, --depth, alpha, beta, true, initial_turn));\n\t\tmaximizing_player ? alpha = std::max(alpha, points) : beta = std::min(beta, points);\n\t\t++depth;\n\t\tc.MovePieceBack(node.first[0], node.first[1], node.first[2], node.first[3]);\n\t\tif(alpha >= beta)\n\t\t\tbreak;\n\t}\n\tchild_node_list.clear();\n\treturn points;\n}\n\n// the main function which returns the optimal move calculated by the alpha-beta algorithm\nstd::string PathNode::AlphaBetaRoot(Chess &c, unsigned short &difficulty) noexcept {\n\tCreateSubtree(c);\n\tstd::vector<std::string> ideal_moves;\n\tfloat max_move_score = -9999;\n\tfor(auto &node : child_node_list) {\n\t\tif(c.GetPiece(node.first[2], node.first[3]) == W_KING - 7*c.GetTurn()) {\n\t\t\tchild_node_list.clear();\n\t\t\treturn node.first;\t\t\t\t\t\t// if my target piece is king, then this move is a game winner so return this move\n\t\t}\n\t\tc.MovePiece(node.first[0], node.first[1], node.first[2], node.first[3], false, false);\n\t\tfloat move_score = node.second.AlphaBeta(c, difficulty, -10000, 10000, false, !c.GetTurn());\n\t\tif(move_score > max_move_score) {\n\t\t\tmax_move_score = move_score;\n\t\t\tideal_moves.clear();\n\t\t\tideal_moves.emplace_back(node.first);\t// add the most rewarding move to the list\n\t\t}\n\t\telse if(move_score == max_move_score)\n\t\t\tideal_moves.emplace_back(node.first);\n\t\tc.MovePieceBack(node.first[0], node.first[1], node.first[2], node.first[3]);\n\t}\n\tchild_node_list.clear();\t\t\t\t\t\t// delete the whole tree\n\tauto move = ideal_moves.cbegin();\n\tadvance(move, GetRandomNumber<unsigned short>(0, ideal_moves.size()-1));\n\treturn *move;\n}\n\n\n\nint main(){\n\n    \n    std::string s1,s2;\n   \n    int i = 0;\n\tChess c(\"0\", WHITE_BOT_DIFFICULTY, \"1\", BLACK_BOT_DIFFICULTY);\n\t\n    std::cin >> s1 >> s2;\n\tif(s1 == \"-1\"){\n\t\twhile(c.BotsTurn(s1,s2)){\n\t\t\tstd::cout << s1 <<\" \" << s2<<std::endl;\n\t\t\tstd::cin >> s1 >> s2;  \n\t\t\n\t\t\tc.PlayersTurn(s1,s2);\n\t\t\t\n\t\t\n\t\t};\n\t}else{\n\t\twhile(c.PlayersTurn(s1,s2)){\n\t\t\t\n\t\t\tc.BotsTurn(s1,s2);\n\t\t\t\n\t\t\tstd::cout << s1 <<\" \" << s2<<std::endl;\n\t\t\tstd::cin >> s1 >> s2;  \n\t\t};\n\t}\n    \n    \n    return 0;\n}";

    private readonly string chess_bot2_cpp =
        "\n\n#define BOARD_SIZE 8\n#define BOX_WIDTH 10\n#define DOWN 3\n#define RIGHT 10\n#define TO_DOWN std::string(DOWN, '\\n')\n#define TO_RIGHT std::string(RIGHT, ' ')\n#define CLEAR_LINE std::string(100, ' ')\n#define MOVES_PER_LINE 5\n\n#define AGAINST_BOT true\t\t\t// if true then it's ? vs bot, if false then it's player vs player\n#define TWO_BOTS true\t\t\t\t// assuming AGAINST_BOT is true, if true then it's bot vs bot, if false then it's player vs bot\n#define BOT_IS_WHITE false\t\t\t// assuming AGAINST_BOT is true and TWO_BOTS is false, if true then the bot is team white, black otherwise\n#define WHITE_BOT_RANDOM true\t\t// if true the white bot returns random moves, if false the white bot returns smart moves generated by minimax algorithm\n#define BLACK_BOT_RANDOM false\t\t// if true the black bot returns random moves, if false the black bot returns smart moves generated by minimax algorithm\n#define WHITE_BOT_DIFFICULTY 1\t\t// the tree depth of decision tree of the bot, which is also correlated to the bot's difficulty (aka chess IQ)\n#define BLACK_BOT_DIFFICULTY 1\t\t// 1: easy, 2: medium, 3: hard\n\n// types of chess pieces\ntypedef enum {\n\tB_KING = -6, B_QUEEN, B_BISHOP, B_KNIGHT, B_ROOK, B_PAWN, EMPTY,\n\tW_KING, W_QUEEN, W_BISHOP, W_KNIGHT, W_ROOK, W_PAWN\n} ChessPieces;\n\n// types of player moves\ntypedef enum {\n\tNORMAL, CASTLING, PROMOTION, EN_PASSANT\n} Moves;\n\n// possible options on how the game can end\ntypedef enum {\n\tCHECKMATE, FIFTY_MOVES, THREEFOLD_REP, QUIT\n} Endgame;\n\n// starting position of the board\nconst char STARTING_BOARD[BOARD_SIZE][BOARD_SIZE] = {{B_ROOK, B_KNIGHT, B_BISHOP, B_QUEEN, B_KING, B_BISHOP, B_KNIGHT, B_ROOK},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{W_ROOK, W_KNIGHT, W_BISHOP, W_QUEEN, W_KING, W_BISHOP, W_KNIGHT, W_ROOK}};\n\nclass Player;\nclass PathNode;\nclass Bot;\nclass Chess;\n\n#include <string>\n#include <forward_list>\n#include <vector>\n#include <map>\n#include <iostream>\n#include <algorithm>\n\n\n\n\n// player class declaration\nclass Player {\nprotected:\n\tstd::string name;\t\t\t// name of the player\n\tunsigned short score = 0;\t// score of the player\n\tbool castling = true;\t\t// if true the player can castle, if false the player cannot castle anymore during the game\npublic:\n\tPlayer(const std::string &name) noexcept;\n\tstd::string GetName() const noexcept;\n\tunsigned short GetScore() const noexcept;\n\tbool GetCastling() const noexcept;\n\tvoid SetCastling(const bool &castling) noexcept;\n\tvoid IncreaseScore(const unsigned short &inc) noexcept;\n\tvoid Reset() noexcept;\n\tbool operator== (const Player &p) const noexcept;\n};\n\n// path node class declaration\nclass PathNode {\nprivate:\n\tstd::map<std::string, PathNode> child_node_list;\t// a map where the key (string) corresponds to the player's move and value corresponds to another node, which makes a decision tree\n\tvoid CreateSubtree(Chess &c) noexcept;\n\tfloat AlphaBeta(Chess &c, unsigned short &depth, float alpha, float beta, const bool &maximizing_player, const bool &initial_turn) noexcept;\npublic:\n\tstd::string AlphaBetaRoot(Chess &c, unsigned short &difficulty) noexcept;\n};\n\n// bot class declaration, which inherits from player class\nclass Bot : public Player {\nprivate:\n\tPathNode root;\t\t\t\t\t// the root node of the bot's decision tree\n\tunsigned short difficulty;\t\t// the depth of the bot's decision tree\npublic:\n\tBot(const std::string &name, const unsigned short &difficulty) noexcept;\n\tunsigned short GetDifficulty() const noexcept;\n\tstd::string GetIdealMove(Chess &c) noexcept;\n\tstd::string GetIdealMove(Chess &c, unsigned short difficulty) noexcept;\n\tbool operator== (const Bot &b) const noexcept;\n};\n\n// chess class declaration\nclass Chess {\nprivate:\n\tchar board[BOARD_SIZE][BOARD_SIZE];\t\t// game board\n\tBot white, black;\t\t\t\t\t\t// teams\n\tstd::vector<std::pair<Moves, std::string>> all_game_moves;\t\t// a record which contains all the moves played throughout the game in chronological order\n\tbool whites_turn = true;\t\t\t\t// if true then it's team white's turn, if false then it's team black's turn\n\tunsigned short moves_after_last_pawn_move_or_capture = 0;\t\t// number of moves played after a pawn moved or a capture happened\n\tstatic bool WithinBounds(const short &coord) noexcept;\n\tstatic void ChangeToString(char &x1, char &y1, char &x2, char &y2) noexcept;\n\tstatic std::string ToString(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tstatic std::string PieceNameToString(const char &piece) noexcept;\n\tstatic float EvaluatePiece(const char &piece) noexcept;\n\tstatic void ClearAllMoves(const unsigned short &n) noexcept;\n\tstatic void PrintSeparator(const char &ch) noexcept;\n\tstatic void CopyBoard(const char from[BOARD_SIZE][BOARD_SIZE], char to[BOARD_SIZE][BOARD_SIZE]) noexcept;\n\tstatic bool AreBoardsEqual(const char board1[BOARD_SIZE][BOARD_SIZE], const char board2[BOARD_SIZE][BOARD_SIZE]) noexcept;\n\tstatic bool CanMovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const std::forward_list<std::string> &all_moves) noexcept;\n\tBot& GetCurrentPlayer() noexcept;\n\tBot GetCurrentPlayerConst() const noexcept;\n\tBot& GetOtherPlayer() noexcept;\n\tBot GetOtherPlayerConst() const noexcept;\n\tvoid ChangeTurn() noexcept;\n\tvoid AppendToAllGameMoves(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tvoid Reset() noexcept;\n\tvoid CheckCoordinates(const short &x, const short &y, const std::string &func_name) const noexcept(false);\n\tbool EndGameText(const unsigned short &n, const Endgame &end_game) const noexcept;\n\tshort GetEnPassant(const short &x, const short &y) const noexcept;\n\ttemplate<class Iterator> short GetEnPassant(const char board[BOARD_SIZE][BOARD_SIZE], const Iterator &it) const noexcept;\n\tbool ThreefoldRepetition() const noexcept;\n\tbool IsCheck(const bool &turn) const noexcept;\n\tbool IsCheck(std::string &move) noexcept;\n\tstd::forward_list<std::string> PawnMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> RookMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> KnightMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> BishopMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> QueenMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> KingMoves(const short &x, const short &y) const noexcept;\n\tstd::string GetRandomMove() noexcept;\n\tvoid ManuallyPromotePawn(const short &x, const short &y) noexcept;\n\tvoid UpdateBoard(const short &x, const short &y) const noexcept;\n\tvoid UpdateScore(const Bot &p) const noexcept;\n\tfloat EvaluatePosition(const short &x, const short &y) const noexcept;\n\tvoid PrintAllMovesMadeInOrder() const noexcept;\n\t\npublic:\n    bool CheckEndgame(const unsigned short &n = 0) noexcept;\n\tChess(const std::string &player1, const unsigned short &difficulty1, const std::string &player2, const unsigned short &difficulty2) noexcept;\n\tstatic void ChangeToRealCoordinates(char &x1, char &y1, char &x2, char &y2) noexcept;\n\tchar GetPiece(const short &x, const short &y) const noexcept;\n\tbool GetTurn() const noexcept;\n\tstd::forward_list<std::string> AllMoves() noexcept;\n\tvoid MovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const bool &manual_promotion, const bool &update_board) noexcept;\n\tvoid MovePieceBack(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tfloat EvaluateBoard(const bool &turn) const noexcept;\n\tvoid PrintBoard() const noexcept;\n\tbool PlayersTurn(std::string s1,std::string s2) noexcept;\n\tbool BotsTurn(std::string &s1, std::string &s2) noexcept;\n\tbool GameOver() noexcept;\n    std::string GetWinner();\n};\n\n// other function declarations\n\nstd::string ToLowerString(std::string s) noexcept;\ntemplate<class T> T GetRandomNumber(const T &min, const T &max) noexcept;\n\t//CHESS_H\n\n\n// function definitions\n\n// moves the cursor to a different (x, y) location on the terminal\n\n\n// returns the given string in lowercase\nstd::string ToLowerString(std::string s) noexcept {\n\ttransform(s.begin(), s.end(), s.begin(), [](const unsigned char &c){ return tolower(c); });\n\treturn s;\n}\n\n// returns a random number between \"min\" and \"max\"\ntemplate<class T> T GetRandomNumber(const T &min, const T &max) noexcept {\n\treturn min + T(static_cast<double>(rand()) / static_cast<double>(RAND_MAX+1.0) * (max-min+1));\n}\n\n\n\n// chess class implementation\n std::string Chess::GetWinner(){\n    return this->GetOtherPlayerConst().GetName();\n }\n// constructor of chess class\nChess::Chess(const std::string &player1, const unsigned short &difficulty1, const std::string &player2, const unsigned short &difficulty2) noexcept\n: white(player1, difficulty1), black(player2, difficulty2) {\n\tCopyBoard(STARTING_BOARD, board);\n}\n\n// checks whether the given coordinate is within board boundaries or not\nbool Chess::WithinBounds(const short &coord) noexcept {\n\treturn coord>=0 && coord<BOARD_SIZE;\n}\n\n// changes the given board coordinates from ASCII to numerical, e.g. ('d', '3') -> (3, 5)\nvoid Chess::ChangeToRealCoordinates(char &x1, char &y1, char &x2, char &y2) noexcept {\n\tx1 -= 'a', x2 -= 'a';\n\ty1 = '8'-y1, y2 = '8'-y2;\n}\n\n// changes the given board coordinates from numerical to ASCII, e.g. (3, 5) -> ('d', '3')\nvoid Chess::ChangeToString(char &x1, char &y1, char &x2, char &y2) noexcept {\n\tx1 += 'a', x2 += 'a';\n\ty1 = '8'-y1, y2 = '8'-y2;\n}\n\n// returns the given numerical board coordinates as a string\nstd::string Chess::ToString(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\treturn {static_cast<char>(x1+'a'), static_cast<char>('8'-y1), static_cast<char>(x2+'a'), static_cast<char>('8'-y2)};\n}\n\n// returns the name that is displayed on the terminal for the given piece\nstd::string Chess::PieceNameToString(const char &piece) noexcept {\n\tswitch(piece) {\n\t\tcase W_PAWN:\treturn \"W_PAWN\";\n\t\tcase B_PAWN:\treturn \"B_PAWN\";\n\t\tcase W_ROOK:\treturn \"W_ROOK\";\n\t\tcase B_ROOK:\treturn \"B_ROOK\";\n\t\tcase W_KNIGHT:\treturn \"W_KNIGHT\";\n\t\tcase B_KNIGHT:\treturn \"B_KNIGHT\";\n\t\tcase W_BISHOP:\treturn \"W_BISHOP\";\n\t\tcase B_BISHOP:\treturn \"B_BISHOP\";\n\t\tcase W_QUEEN:\treturn \"W_QUEEN\";\n\t\tcase B_QUEEN:\treturn \"B_QUEEN\";\n\t\tcase W_KING:\treturn \"W_KING\";\n\t\tcase B_KING:\treturn \"B_KING\";\n\t\tdefault:\t\treturn \"\";\n\t}\n}\n\n// returns the worth of the given piece in terms of points\nfloat Chess::EvaluatePiece(const char &piece) noexcept {\n\tswitch(piece) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\treturn 10;\t\t// pawn: 10 points\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\treturn 50;\t\t// rook: 50 points\n\t\tcase W_KNIGHT:\n\t\tcase B_KNIGHT:\n\t\tcase W_BISHOP:\n\t\tcase B_BISHOP:\treturn 30;\t\t// knight and bishop: 30 points\n\t\tcase W_QUEEN:\n\t\tcase B_QUEEN:\treturn 90;\t\t// queen: 90 points\n\t\tcase W_KING:\n\t\tcase B_KING:\treturn 900;\t\t// king: 900 points, but you can assume it is infinite\n\t\tdefault:\t\treturn 0;\n\t}\n}\n\n// clears all available moves from the terminal\nvoid Chess::ClearAllMoves(const unsigned short &n) noexcept {\n\n}\n\n// prints the vertical seperators for the game board on the terminal\nvoid Chess::PrintSeparator(const char &ch) noexcept {\n\n}\n\n// copies the board contents of \"from\" to \"to\"\nvoid Chess::CopyBoard(const char from[BOARD_SIZE][BOARD_SIZE], char to[BOARD_SIZE][BOARD_SIZE]) noexcept {\n\tstd::copy(*from, *from + BOARD_SIZE*BOARD_SIZE, *to);\n}\n\n// checks whether the board positions of the given two boards are equal or not\nbool Chess::AreBoardsEqual(const char board1[BOARD_SIZE][BOARD_SIZE], const char board2[BOARD_SIZE][BOARD_SIZE]) noexcept {\n\treturn std::equal(*board1, *board1 + BOARD_SIZE*BOARD_SIZE, *board2);\n}\n\nbool Chess::CanMovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const std::forward_list<std::string> &all_moves) noexcept {\n\treturn std::find(all_moves.cbegin(), all_moves.cend(), ToString(x1, y1, x2, y2)) != all_moves.cend();\n}\n\n// getter method, returns the piece located in the given x and y coordinates\nchar Chess::GetPiece(const short &x, const short &y) const noexcept {\n//\tCheckCoordinates(x, y, \"GetPiece\");\n\treturn board[y][x];\n}\n\n// getter method, returns whether it's team white's turn or not\nbool Chess::GetTurn() const noexcept {\n\treturn whites_turn;\n}\n\n// returns a reference to the player object\nBot& Chess::GetCurrentPlayer() noexcept {\n\treturn whites_turn ? white : black;\n}\n\n// returns a copy of the player object\nBot Chess::GetCurrentPlayerConst() const noexcept {\n\treturn whites_turn ? white : black;\n}\n\n// returns a reference to the player object\nBot& Chess::GetOtherPlayer() noexcept {\n\treturn whites_turn ? black : white;\n}\n\n// returns a copy of the player object\nBot Chess::GetOtherPlayerConst() const noexcept {\n\treturn whites_turn ? black : white;\n}\n\n// changes whose turn it is so the other player can make its move\nvoid Chess::ChangeTurn() noexcept {\n\twhites_turn = !whites_turn;\n}\n\n// appends the last made game move to \"all_game_moves\" list\nvoid Chess::AppendToAllGameMoves(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\tif(GetCurrentPlayerConst().GetCastling() && (board[y1][x1] == B_KING + 7*whites_turn) && (x2 == 2 || x2 == 6))\n\t\tall_game_moves.emplace_back(CASTLING, std::string(1, x2));\n\telse\n\t\tall_game_moves.emplace_back(NORMAL, ToString(x1, y1, x2, y2) + board[y1][x1] + board[y2][x2]);\n}\n\n// resets the game, everything is back to its default value\nvoid Chess::Reset() noexcept {\n\tCopyBoard(STARTING_BOARD, board);\n\twhite.Reset();\n\tblack.Reset();\n\tall_game_moves.clear();\n\twhites_turn = true;\n\tmoves_after_last_pawn_move_or_capture = 0;\n\tsystem(\"cls\");\n}\n\n// a function for exception handling, checks whether the given coordinates is within board boundaries or not\nvoid Chess::CheckCoordinates(const short &x, const short &y, const std::string &func_name) const noexcept(false) {\n\ttry {\n\t\tif(!WithinBounds(x))\t\tthrow x;\n\t\tif(!WithinBounds(y))\t\tthrow y;\n\t}\n\tcatch(const short &coord) {\n\t\tstd::cerr << std::endl << std::endl << TO_RIGHT << \"!ERROR!\\t\\tInvalid coordinate: '\" << coord << \"'.\\t\\t!ERROR!\";\n\t\tstd::cerr << std::endl << TO_RIGHT << \"      \\t\\tException occurred in \\\"\" << func_name << \"\\\".\";\n\t\tPrintAllMovesMadeInOrder();\n\t\texit(1);\n\t}\n}\n\n// prints game over message to the terminal\nbool Chess::EndGameText(const unsigned short &n, const Endgame &end_game) const noexcept {\n\tClearAllMoves(n);\n\n\tswitch(end_game) {\n\t\tcase CHECKMATE:\n\t\t\t\n\t\t\treturn true;\n\t\tdefault:\n\t\t\t//Draw!!!\n\t\t\tswitch(end_game) {\n\t\t\t\tcase FIFTY_MOVES:\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\tcase THREEFOLD_REP:\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t}\n}\n\n// returns the x coordinate of the eaten pawn piece\nshort Chess::GetEnPassant(const short &x, const short &y) const noexcept {\n\tif(all_game_moves.empty())\n\t\treturn -1;\n\tif(all_game_moves.back().first != NORMAL)\n\t\treturn -1;\n\tauto last_move = all_game_moves.back().second;\n\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\treturn ((last_move[4] == W_PAWN - 7*whites_turn) && (abs(last_move[0] - x) == 1) && (last_move[3]-last_move[1] == 2*(whites_turn ? 1 : -1)) && (y == 4 - whites_turn)) ? last_move[0] : -1;\n}\n\n// returns the x coordinate of the en passant move\ntemplate<class Iterator> short Chess::GetEnPassant(const char board[BOARD_SIZE][BOARD_SIZE], const Iterator &it) const noexcept {\n\tif(it->first != NORMAL)\n\t\treturn -1;\n\tauto last_move = it->second;\n\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\tfor(short x=0;x<BOARD_SIZE;++x)\n\t\tif(board[3 + whites_turn][x] == W_PAWN - 7*whites_turn)\n\t\t\tif((last_move[4] == B_PAWN + 7*whites_turn) && (abs(last_move[0] - x) == 1) && (last_move[3] - last_move[1] == 2*(whites_turn ? -1 : 1)))\n\t\t\t\treturn last_move[0];\n\treturn -1;\n}\n\n// returns true if threefold repetition occurs, false otherwise\nbool Chess::ThreefoldRepetition() const noexcept {\n\tstatic char prev_board[BOARD_SIZE][BOARD_SIZE];\n\tCopyBoard(board, prev_board);\n\tunsigned short position_count = 1;\n\tauto it = all_game_moves.crbegin();\n\tauto last_move = it->second;\n\twhile(true) {\n\t\tfor(unsigned short i=0;i<2;++i)\t{\n\t\t\tswitch(it->first) {\n\t\t\t\tcase CASTLING:\n\t\t\t\t\treturn false;\t\t// if a pawn has moved or a castling/capture has occured, then that board position is unique and repetition is not possible\n\t\t\t\tdefault:\n\t\t\t\t\tif(last_move[4] == W_PAWN || last_move[4] == B_PAWN || last_move[5] != EMPTY)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\t\t\t\t\tprev_board[short(last_move[1])][short(last_move[0])] = last_move[4], prev_board[short(last_move[3])][short(last_move[2])] = EMPTY;\n\t\t\t\t\tif(it->first == EN_PASSANT)\n\t\t\t\t\t\tprev_board[short(last_move[1])][short(last_move[2])] = i == whites_turn ? B_PAWN : W_PAWN;\n\t\t\t}\n\t\t\tif((++it) == all_game_moves.crend())\n\t\t\t\treturn false;\n\t\t\tlast_move = it->second;\n\t\t}\n\t\tif(AreBoardsEqual(prev_board, board))\t\t// check for castling and en passant in every 2 turns\n\t\t\tif(GetOtherPlayerConst().GetCastling() == (it->first == CASTLING ? false : last_move[6 + (it->first == PROMOTION)]))\n\t\t\t\tif((all_game_moves.size() > 1 ? GetEnPassant(board, prev(all_game_moves.cend(), 2)) : -1)\n\t\t\t\t== (next(it) == all_game_moves.crend() ? -1 : GetEnPassant(prev_board, next(it))))\n\t\t\t\t\tif((++position_count) == 3)\n\t\t\t\t\t\treturn true;\n\t}\n}\n\n// returns true if the player's king is in check, false otherwise\nbool Chess::IsCheck(const bool &turn) const noexcept {\n\tshort x = -1, y = -1;\n\tfor(short i=0;x==-1;++i)\n\t\tfor(short j=0;j<BOARD_SIZE;++j)\n\t\t\tif(board[j][i] == B_KING + 7*turn) {\n\t\t\t\tx = i, y = j;\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(short i=x+1;i<BOARD_SIZE;++i)\t\t\t\t\t\t// check queen and rook\n\t\tif(board[y][i] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[y][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[y][i] != EMPTY)\tbreak;\n\tfor(short i=x-1;i>=0;--i)\n\t\tif(board[y][i] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[y][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[y][i] != EMPTY)\tbreak;\n\tfor(short i=y+1;i<BOARD_SIZE;++i)\n\t\tif(board[i][x] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[i][x] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[i][x] != EMPTY)\tbreak;\n\tfor(short i=y-1;i>=0;--i)\n\t\tif(board[i][x] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[i][x] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[i][x] != EMPTY)\tbreak;\n\tfor(short i=x-1, j=y-1; i>=0 && j>=0; --i, --j)\t\t\t// check queen and bishop\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x-1, j=y+1; i>=0 && j<BOARD_SIZE; --i, ++j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x+1, j=y-1; i<BOARD_SIZE && j>=0; ++i, --j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x+1, j=y+1; i<BOARD_SIZE && j<BOARD_SIZE; ++i, ++j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x-1;i<x+2;++i)\t\t\t\t\t\t\t\t// check king\n\t\tfor(short j=y-1;j<y+2;++j)\n\t\t\tif((board[j][i] == W_KING - 7*turn) && WithinBounds(i) && WithinBounds(j))\t\t\treturn true;\n\tif((board[y-1][x-2] == W_KNIGHT - 7*turn) && (y > 0) && (x > 1))\t\t\t\t\t\t\treturn true;\t// check knight\n\telse if((board[y-1][x+2] == W_KNIGHT - 7*turn) && (y > 0) && (x < BOARD_SIZE-2))\t\t\treturn true;\n\telse if((board[y+1][x-2] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-1) && (x > 1))\t\t\treturn true;\n\telse if((board[y+1][x+2] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-1) && (x < BOARD_SIZE-2))\treturn true;\n\telse if((board[y-2][x-1] == W_KNIGHT - 7*turn) && (y > 1) && (x > 0))\t\t\t\t\t\treturn true;\n\telse if((board[y-2][x+1] == W_KNIGHT - 7*turn) && (y > 1) && (x < BOARD_SIZE-1))\t\t\treturn true;\n\telse if((board[y+2][x-1] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-2) && (x > 0))\t\t\treturn true;\n\telse if((board[y+2][x+1] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-2) && (x < BOARD_SIZE-1))\treturn true;\n\telse if((board[y + (turn ? -1 : 1)][x+1] == W_PAWN - 7*turn) && (x < BOARD_SIZE-1))\t\t\treturn true;\t// check pawn\n\telse if((board[y + (turn ? -1 : 1)][x-1] == W_PAWN - 7*turn) && (x > 0))\t\t\t\t\treturn true;\n\treturn false;\n}\n\n// function overload, returns true if the player's king is in check, false otherwise\nbool Chess::IsCheck(std::string &move) noexcept {\n\tChangeToRealCoordinates(move[0], move[1], move[2], move[3]);\n\tMovePiece(move[0], move[1], move[2], move[3], false, false);\n\tconst bool &is_check = IsCheck(!whites_turn);\n\tMovePieceBack(move[0], move[1], move[2], move[3]);\n\tChangeToString(move[0], move[1], move[2], move[3]);\n\treturn is_check;\n}\n\n// returns a list of all possible moves the pawn located in (x, y) can make\nstd::forward_list<std::string> Chess::PawnMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tconst short &inc = whites_turn ? -1 : 1;\n\tstd::forward_list<std::string> all_moves;\n\tif(board[y+inc][x] == EMPTY) {\n\t\tall_moves.emplace_front(ToString(x, y, x, y+inc));\t\t\t\t// 1 square forward\n\t\tif((y == 1 + 5*whites_turn) && (board[y + 2*inc][x] == EMPTY))\n\t\t\tall_moves.emplace_front(ToString(x, y, x, y + 2*inc));\t\t// 2 squares forward\n\t}\n\tif(GetEnPassant(x, y) != -1)\n\t\tall_moves.emplace_front(ToString(x, y, GetEnPassant(x, y), y+inc));\n\tif(IsValid(board[y+inc][x+1]) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y+inc));\t\t// diagonal attack moves\n\tif(IsValid(board[y+inc][x-1]) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y+inc));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the rook located in (x, y) can make\nstd::forward_list<std::string> Chess::RookMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x+1;i<BOARD_SIZE;++i)\t\t\t// right\n\t\tif(board[y][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\telse {\n\t\t\tif(IsValid(board[y][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x-1;i>=0;--i)\t\t\t\t\t// left\n\t\tif(board[y][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\telse {\n\t\t\tif(IsValid(board[y][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=y+1;i<BOARD_SIZE;++i)\t\t\t// down\n\t\tif(board[i][x] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\telse {\n\t\t\tif(IsValid(board[i][x]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=y-1;i>=0;--i)\t\t\t\t\t// up\n\t\tif(board[i][x] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\telse {\n\t\t\tif(IsValid(board[i][x]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\t\tbreak;\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the knight located in (x, y) can make\nstd::forward_list<std::string> Chess::KnightMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch <= 0; } : [](const char &ch){ return ch >= 0; };\n\tstd::forward_list<std::string> all_moves;\n\tif(IsValid(board[y-1][x-2]) && (y > 0) && (x > 1))\n\t\tall_moves.emplace_front(ToString(x, y, x-2, y-1));\n\tif(IsValid(board[y-1][x+2]) && (y > 0) && (x < BOARD_SIZE-2))\n\t\tall_moves.emplace_front(ToString(x, y, x+2, y-1));\n\tif(IsValid(board[y+1][x-2]) && (y < BOARD_SIZE-1) && (x > 1))\n\t\tall_moves.emplace_front(ToString(x, y, x-2, y+1));\n\tif(IsValid(board[y+1][x+2]) && (y < BOARD_SIZE-1) && (x < BOARD_SIZE-2))\n\t\tall_moves.emplace_front(ToString(x, y, x+2, y+1));\n\tif(IsValid(board[y-2][x-1]) && (y > 1) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y-2));\n\tif(IsValid(board[y-2][x+1]) && (y > 1) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y-2));\n\tif(IsValid(board[y+2][x-1]) && (y < BOARD_SIZE-2) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y+2));\n\tif(IsValid(board[y+2][x+1]) && (y < BOARD_SIZE-2) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y+2));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the bishop located in (x, y) can make\nstd::forward_list<std::string> Chess::BishopMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x-1, j=y-1; i>=0 && j>=0; --i, --j)\t\t\t\t\t\t// upper left diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x-1, j=y+1; i>=0 && j<BOARD_SIZE; --i, ++j)\t\t\t\t// lower left diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x+1, j=y-1; i<BOARD_SIZE && j>=0; ++i, --j)\t\t\t\t// upper right diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x+1, j=y+1; i<BOARD_SIZE && j<BOARD_SIZE; ++i, ++j)\t\t// lower right diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the queen located in (x, y) can make\nstd::forward_list<std::string> Chess::QueenMoves(const short &x, const short &y) const noexcept {\n\tauto all_moves = RookMoves(x, y);\t\t\t// queen = rook + bishop\n\tall_moves.merge(BishopMoves(x, y));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the king located in (x, y) can make\nstd::forward_list<std::string> Chess::KingMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch <= 0; } : [](const char &ch){ return ch >= 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x-1;i<x+2;++i)\t\t// add moves within 1 square reach\n\t\tfor(short j=y-1;j<y+2;++j)\n\t\t\tif(IsValid(board[j][i]) && WithinBounds(i) && WithinBounds(j))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\tif(GetCurrentPlayerConst().GetCastling())\t\t// add castling moves if castling is possible\n\t\tif(!IsCheck(whites_turn)) {\n\t\t\tconst short &line = (BOARD_SIZE-1)*whites_turn;\n\t\t\tif((board[line][0] == B_ROOK + 7*whites_turn) && board[line][1] == EMPTY && board[line][2] == EMPTY && board[line][3] == EMPTY)\n\t\t\t\tall_moves.emplace_front(ToString(4, line, 2, line));\t// long castling\n\t\t\telse if((board[line][7] == B_ROOK + 7*whites_turn) && board[line][5] == EMPTY && board[line][6] == EMPTY)\n\t\t\t\tall_moves.emplace_front(ToString(4, line, 6, line));\t// short castling\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the player can make\nstd::forward_list<std::string> Chess::AllMoves() noexcept {\n\tstd::forward_list<std::string> all_moves;\n\tfor(short y=0;y<BOARD_SIZE;++y)\n\t\tfor(short x=0;x<BOARD_SIZE;++x) {\n\t\t\tif((board[y][x] < 0) == whites_turn)\n\t\t\t\tcontinue;\n\t\t\tswitch(board[y][x]) {\n\t\t\t\tcase W_PAWN:\n\t\t\t\tcase B_PAWN:\n\t\t\t\t\tall_moves.merge(PawnMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_ROOK:\n\t\t\t\tcase B_ROOK:\n\t\t\t\t\tall_moves.merge(RookMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_KNIGHT:\n\t\t\t\tcase B_KNIGHT:\n\t\t\t\t\tall_moves.merge(KnightMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_BISHOP:\n\t\t\t\tcase B_BISHOP:\n\t\t\t\t\tall_moves.merge(BishopMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_QUEEN:\n\t\t\t\tcase B_QUEEN:\n\t\t\t\t\tall_moves.merge(QueenMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_KING:\n\t\t\t\tcase B_KING:\n\t\t\t\t\tall_moves.merge(KingMoves(x, y));\n\t\t\t}\n\t\t}\n\tfor(auto it = all_moves.begin(), prev = all_moves.before_begin(); it != all_moves.cend();)\t\t// if the possible move makes me checkmate after the opponent's turn, remove it from the list\n\t\tif(IsCheck(*it))\n\t\t\tit = all_moves.erase_after(prev);\n\t\telse\n\t\t\t++it, ++prev;\n\treturn all_moves;\n}\n\n// returns a random move the player can make\nstd::string Chess::GetRandomMove() noexcept {\n\tauto all_moves = AllMoves();\n\tauto move = all_moves.begin();\n\tadvance(move, GetRandomNumber<unsigned short>(0, distance(all_moves.cbegin(), all_moves.cend()) - 1));\n\tChangeToRealCoordinates((*move)[0], (*move)[1], (*move)[2], (*move)[3]);\n\treturn *move;\n}\n\n// asks the player it's choice of promotion, then promotes the pawn to the desired piece\nvoid Chess::ManuallyPromotePawn(const short &x, const short &y) noexcept {\n\t\n\tchar key = 'q';\n\t\n\t\tswitch(key = tolower(key)) {\n\t\t\tcase 'r':\tboard[y][x] = whites_turn ? W_ROOK : B_ROOK;\t\treturn;\n\t\t\tcase 'k':\tboard[y][x] = whites_turn ? W_KNIGHT : B_KNIGHT;\treturn;\n\t\t\tcase 'b':\tboard[y][x] = whites_turn ? W_BISHOP : B_BISHOP;\treturn;\n\t\t\tcase 'q':\tboard[y][x] = whites_turn ? W_QUEEN : B_QUEEN;\t\treturn;\n\t\t\t\n\t\t}\n}\n\n// moves the piece from (x1, y1) to (x2, y2)\nvoid Chess::MovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const bool &manual_promotion, const bool &update_board) noexcept {\n//\tCheckCoordinates(x1, y1, \"MovePiece\");\n//\tCheckCoordinates(x2, y2, \"MovePiece\");\n\tAppendToAllGameMoves(x1, y1, x2, y2);\t\t// similar to FEN notation but not really, the starting and ending points of the moving piece, promoted piece if there is promotion and ability to do castling\n\tswitch(board[y1][x1]) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\n\t\t\tif(y2 == ((BOARD_SIZE-1) * !whites_turn)) {\t\t\t// check for castling, promotion or en passant\n\t\t\t\tif(manual_promotion) {\n\t\t\t\t\tManuallyPromotePawn(x1, y1);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(whites_turn ? WHITE_BOT_RANDOM : BLACK_BOT_RANDOM)\n\t\t\t\t\tboard[y1][x1] = (whites_turn ? 1 : -1) * GetRandomNumber(2, 5);\n\t\t\t\telse\n\t\t\t\t\tboard[y1][x1] = whites_turn ? W_QUEEN : B_QUEEN;\n\t\t\t\tall_game_moves.back().first = PROMOTION;\n\t\t\t\tall_game_moves.back().second.push_back(board[y1][x1]);\n\t\t\t}\n\t\t\telse if(x1 != x2 && board[y2][x2] == EMPTY) {\n\t\t\t\tboard[y1][x2] = EMPTY;\n\t\t\t\tif(update_board) {\n\t\t\t\t\tGetCurrentPlayer().IncreaseScore(EvaluatePiece(W_PAWN));\n\t\t\t\t\tUpdateScore(GetCurrentPlayerConst());\n\t\t\t\t\tUpdateBoard(x2, y1);\n\t\t\t\t}\n\t\t\t\tall_game_moves.back().first = EN_PASSANT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase W_KING:\n\t\tcase B_KING:\n\t\t\tif(GetCurrentPlayerConst().GetCastling()) {\n\t\t\t\tconst short &line = (BOARD_SIZE-1) * whites_turn;\n\t\t\t\tswitch(x2) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tboard[line][3] = board[line][0], board[line][0] = EMPTY;\n\t\t\t\t\t\tif(update_board) {\n\t\t\t\t\t\t\tUpdateBoard(0, line);\n\t\t\t\t\t\t\tUpdateBoard(3, line);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tboard[line][5] = board[line][7], board[line][7] = EMPTY;\n\t\t\t\t\t\tif(update_board) {\n\t\t\t\t\t\t\tUpdateBoard(7, line);\n\t\t\t\t\t\t\tUpdateBoard(5, line);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\n\t\t\tGetCurrentPlayer().SetCastling(false);\n\t}\n\tif(all_game_moves.back().first != CASTLING)\t\t\t\tall_game_moves.back().second.push_back(GetCurrentPlayerConst().GetCastling());\n\tboard[y2][x2] = board[y1][x1], board[y1][x1] = EMPTY;\n\tif(update_board) {\n\t\tif(all_game_moves.back().first != CASTLING)\n\t\t\tif(all_game_moves.back().second[5] != EMPTY) {\n\t\t\t\tGetCurrentPlayer().IncreaseScore(EvaluatePiece(all_game_moves.back().second[5]));\n\t\t\t\tUpdateScore(GetCurrentPlayerConst());\n\t\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// the piece is eaten\n\t\t\t}\n\t\tUpdateBoard(x1, y1);\n\t\tUpdateBoard(x2, y2);\n\t}\n\tChangeTurn();\t\t// it's the opponent's turn\n}\n\n// undoes the move from (x1,y1) to (x2,y2), the opposite of the \"MovePiece\" function\nvoid Chess::MovePieceBack(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\tChangeTurn();\n\tboard[y1][x1] = board[y2][x2], board[y2][x2] = all_game_moves.back().first == CASTLING ? static_cast<char>(EMPTY) : all_game_moves.back().second[5];\n\tswitch(board[y1][x1]) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\n\t\t\tif(x1 != x2 && board[y2][x2] == EMPTY)\n\t\t\t\tboard[y1][x2] = whites_turn ? B_PAWN : W_PAWN;\n\t\t\tbreak;\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\n\t\t\tif(prev(all_game_moves.cend(), 3)->first != CASTLING)\n\t\t\t\tif(prev(all_game_moves.cend(), 3)->second[6 + (prev(all_game_moves.cend(), 3)->first == PROMOTION)])\n\t\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t\t\tbreak;\n\t\tcase W_QUEEN:\n\t\tcase B_QUEEN:\n\t\t\tif(all_game_moves.back().first == PROMOTION)\n\t\t\t\tboard[y1][x1] = whites_turn ? W_PAWN : B_PAWN;\n\t\t\tbreak;\n\t\tcase W_KING:\n\t\tcase B_KING:\n\t\t\tif(all_game_moves.back().first == CASTLING) {\n\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t\t\t\tconst short line = (BOARD_SIZE-1) * whites_turn;\n\t\t\t\tswitch(x2) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tboard[line][0] = board[line][3], board[line][3] = EMPTY;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tboard[line][7] = board[line][5], board[line][5] = EMPTY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(prev(all_game_moves.cend(), 3)->first != CASTLING)\n\t\t\t\tif(prev(all_game_moves.cend(), 3)->second[6 + (prev(all_game_moves.cend(), 3)->first == PROMOTION)])\n\t\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t}\n\tall_game_moves.pop_back();\n}\n\n// updates the board display on the terminal\nvoid Chess::UpdateBoard(const short &x, const short &y) const noexcept {\n\tconst unsigned short &diff = BOX_WIDTH - PieceNameToString(board[y][x]).length();\n\t\n}\n\n// updates the score display on the terminal\nvoid Chess::UpdateScore(const Bot &p) const noexcept {\n\tconst unsigned short &dx = p==white ? white.GetName().length() + 2 : (BOX_WIDTH+1)*BOARD_SIZE - 5;\n\t\n\n}\n\n// returns the worth of the position of the piece in terms of points\nfloat Chess::EvaluatePosition(const short &x, const short &y) const noexcept {\n\tif(board[y][x] == EMPTY)\n\t\treturn 0;\n\tstatic float PIECE_POS_POINTS[6][BOARD_SIZE][BOARD_SIZE] =\n\t{{{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\t\t// king\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-2.0, -3.0, -3.0, -4.0, -4.0, -3.0, -3.0, -2.0},\n\t{-1.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -1.0},\n\t{2.0, 2.0, 0.0, 0.0, 0.0, 0.0, 2.0, 2.0},\n\t{2.0, 3.0, 1.0, 0.0, 0.0, 1.0, 3.0, 2.0}}\n\t,\n\t{{-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0},\t\t// queen\n\t{-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0},\n\t{-0.5, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5},\n\t{0.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5},\n\t{-1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0}}\n\t,\n\t{{-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0},\t\t// bishop\n\t{-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 1.0, 1.0, 0.5, 0.0, -1.0},\n\t{-1.0, 0.5, 0.5, 1.0, 1.0, 0.5, 0.5, -1.0},\n\t{-1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, -1.0},\n\t{-1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0},\n\t{-1.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, -1.0},\n\t{-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0}}\n\t,\n\t{{-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0},\t\t// knight\n\t{-4.0, -2.0, 0.0, 0.0, 0.0, 0.0, -2.0, -4.0},\n\t{-3.0, 0.0, 1.0, 1.5, 1.5, 1.0, 0.0, -3.0},\n\t{-3.0, 0.5, 1.5, 2.0, 2.0, 1.5, 0.5, -3.0},\n\t{-3.0, 0.0, 1.5, 2.0, 2.0, 1.5, 0.0, -3.0},\n\t{-3.0, 0.5, 1.0, 1.5, 1.5, 1.0, 0.5, -3.0},\n\t{-4.0, -2.0, 0.0, 0.5, 0.5, 0.0, -2.0, -4.0},\n\t{-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0}}\n\t,\n\t{{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\t\t\t\t// rook\n\t{0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0}}\n\t,\n\t{{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\t\t\t\t// pawn\n\t{5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0},\n\t{1.0, 1.0, 2.0, 3.0, 3.0, 2.0, 1.0, 1.0},\n\t{0.5, 0.5, 1.0, 2.5, 2.5, 1.0, 0.5, 0.5},\n\t{0.0, 0.0, 0.0, 2.0, 2.0, 0.0, 0.0, 0.0},\n\t{0.5, -0.5, -1.0, 0.0, 0.0, -1.0, -0.5, 0.5},\n\t{0.5, 1.0, 1.0, -2.0, -2.0, 1.0, 1.0, 0.5},\n\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}}};\t\t\t\t// returns negative points if the pieces are black, positive points if the pieces are white\n\treturn (board[y][x]<0 ? -1 : 1) * (EvaluatePiece(board[y][x]) + PIECE_POS_POINTS[board[y][x] + 7*(board[y][x]<0) - 1][board[y][x]<0 ? BOARD_SIZE-y-1 : y][x]);\n}\n\n// returns the worth of the board position in terms of points\nfloat Chess::EvaluateBoard(const bool &turn) const noexcept {\n\tfloat total_evaluation = 0.0;\n\tfor(short y=0;y<BOARD_SIZE;++y)\n\t\tfor(short x=0;x<BOARD_SIZE;++x)\n\t\t\ttotal_evaluation += EvaluatePosition(x, y);\n\treturn (turn ? 1 : -1) * total_evaluation;\n}\n\n// prints the game board on the terminal\nvoid Chess::PrintBoard() const noexcept {\n\tstd::cout << TO_DOWN << TO_RIGHT;\n\tfor(short y=0;y<BOARD_SIZE;++y) {\n\t\tPrintSeparator(' ');\n\t\tstd::cout << \"\\b\\b\\b\" << BOARD_SIZE-y << \"  \";\n\t\tfor(short x=0;x<BOARD_SIZE;++x) {\n\t\t\tconst unsigned short &diff = BOX_WIDTH - PieceNameToString(board[y][x]).length();\n\t\t\tstd::cout << std::string(diff/2, ' ') << PieceNameToString(board[y][x]) << std::string(diff/2, ' ');\n\t\t\tif(diff%2)\t\t\t\tstd::cout << \" \";\n\t\t\tif(x < BOARD_SIZE-1)\tstd::cout << \"|\";\n\t\t}\n\t\tif(y < BOARD_SIZE-1) {\n\t\t\tstd::cout << std::endl << TO_RIGHT;\n\t\t\tPrintSeparator('_');\n\t\t}\n\t}\n\tstd::cout << std::endl << TO_RIGHT;\n\tPrintSeparator(' ');\n\tfor(char ch='a';ch<'a'+BOARD_SIZE;++ch)\n\t\tstd::cout << std::string(BOX_WIDTH/2, ' ') << ch << std::string(BOX_WIDTH/2, ' ');\n\tstd::cout << std::endl << std::endl << TO_RIGHT << white.GetName() << \": 0\";\n\tstd::cout << std::string((BOX_WIDTH+1)*BOARD_SIZE - white.GetName().length() - black.GetName().length() - 10, ' ') << black.GetName() << \": 0\";\n\tstd::cout << std::endl << std::endl << TO_RIGHT << white.GetName() << \"'s turn...\";\n\tstd::cout << std::endl << TO_RIGHT << \"Enter move coordinates (x1,y1)->(x2,y2):\";\n\tstd::cout << std::endl << std::endl << TO_RIGHT << \"All possible moves:\" << std::endl;\n}\n\n// after the game is over, prints all moves played throughout the game in chronological order\nvoid Chess::PrintAllMovesMadeInOrder() const noexcept {\n\tstd::cout << std::endl << std::endl << TO_RIGHT << \"All moves made in order:\" << std::endl;\n\tbool turn = true;\n\tfor(const auto &game_move : all_game_moves) {\n\t\tstd::cout << std::endl << TO_RIGHT << (turn ? white : black).GetName() << \": \";\n\t\tswitch(game_move.first) {\n\t\t\tcase CASTLING:\n\t\t\t\tstd::cout << \"castling \" << (game_move.second[0] == 2 ? \"long\" : \"short\");\tbreak;\n\t\t\tdefault:\n\t\t\t\tstd::cout << ToLowerString(PieceNameToString(game_move.second[4])).substr(2) << \" '\" << game_move.second.substr(0, 2) << \"' to \";\n\t\t\t\tif(game_move.second[5] != EMPTY)\n\t\t\t\t\tstd::cout << ToLowerString(PieceNameToString(game_move.second[5])).substr(2) + \" \";\n\t\t\t\tstd::cout << \"'\" << game_move.second.substr(2, 2) << \"'\";\n\t\t\t\tswitch(game_move.first) {\n\t\t\t\t\tcase PROMOTION:\n\t\t\t\t\t\tstd::cout << \" promoted to \" << ToLowerString(PieceNameToString(game_move.second[6])).substr(2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EN_PASSANT:\n\t\t\t\t\t\tstd::cout << \" (en passant)\";\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tturn = !turn;\n\t}\n}\n\n// checks if the game is over or not\nbool Chess::CheckEndgame(const unsigned short &n) noexcept {\n\tif(AllMoves().empty()) {\t\t\t// if the opponent has no moves left, then it is checkmate\n\t\tGetOtherPlayer().IncreaseScore(EvaluatePiece(W_KING));\n\t\tUpdateScore(GetOtherPlayerConst());\n\t\treturn EndGameText(n, CHECKMATE);\n\t}\n\telse if(all_game_moves.back().first != CASTLING) {\n\t\tif(all_game_moves.back().second[4] == W_PAWN - 7*whites_turn)\n\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// pawn has moved\n\t\telse if(all_game_moves.back().second[5] != EMPTY)\n\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// capture has occured\n\t\telse if((++moves_after_last_pawn_move_or_capture) == 50)\n\t\t\treturn EndGameText(n, FIFTY_MOVES);\n\t}\n\telse if((++moves_after_last_pawn_move_or_capture) == 50)\n\t\treturn EndGameText(n, FIFTY_MOVES);\n\tif(ThreefoldRepetition())\n\t\treturn EndGameText(n, THREEFOLD_REP);\n\treturn false;\n}\n\n// lists all possible moves, expects player input and plays the given move if it is valid, expects a valid input otherwise\nbool Chess::PlayersTurn(std::string from,std::string to) noexcept {\n\tauto all_moves = AllMoves();\n\tall_moves.sort();\n\tunsigned short i=0;\n\t\n\tif(IsCheck(whites_turn)) {\n\t\t\n\t\ti += 2*MOVES_PER_LINE;\n\t}\n\t\n\twhile(true) {\n\t\t\n\t\t\n\t\tif(!ToLowerString(from).compare(\"quit\"))\n\t\t\treturn EndGameText(i/MOVES_PER_LINE + 1, QUIT);\n\t\tif(!ToLowerString(from).compare(\"exit\"))\n\t\t\treturn EndGameText(i/MOVES_PER_LINE + 1, QUIT);\n\t\t\n\t\tfrom.resize(2);\n\t\tto.resize(2);\n\t\tfrom.shrink_to_fit();\n\t\tto.shrink_to_fit();\n\t\tfrom[0] = tolower(from[0]), to[0] = tolower(to[0]);\n\t\tChangeToRealCoordinates(from[0], from[1], to[0], to[1]);\n       \n\t\tif((from[0]!=to[0] || from[1]!=to[1]) && WithinBounds(from[0]) && WithinBounds(from[1]) && WithinBounds(to[0]) && WithinBounds(to[1])){\n\t\t\tif(CanMovePiece(from[0], from[1], to[0], to[1], all_moves)) {\n\t\t\t\tMovePiece(from[0], from[1], to[0], to[1], true, true);\n\t\t\t\tif(CheckEndgame(i/MOVES_PER_LINE + 1))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\t}else{\n                return false;\n            }\n        }else{\n            return false;\n        }\n\t\t\n\t\t\n\t}\n\t\n\tClearAllMoves(i/MOVES_PER_LINE + 1);\n\t\n\treturn true;\n}\n\n// plays the bots move\nbool Chess::BotsTurn(std::string &s1, std::string &s2) noexcept {\n\tconst auto &move = (whites_turn ? WHITE_BOT_RANDOM : BLACK_BOT_RANDOM) ? GetRandomMove() : GetCurrentPlayer().GetIdealMove(*this);\n\tMovePiece(move[0], move[1], move[2], move[3], false, true);\n\t\n\ts1 = \"  \";\n\ts2 = \"  \";\n\ts1[0] = move[0]+'a';\n\ts1[1] = '8' - move[1];\n\ts2[0] = move[2]+'a';\n\ts2[1] = '8' - move[3];\n\tif(CheckEndgame())\n\t\treturn false;\n\t\n\treturn true;\n}\n\n// prints game over messages and expects user input for another game\nbool Chess::GameOver() noexcept {\n\t//std::cout << std::endl << std::endl << std::endl << TO_RIGHT << \"Press R to play again.\";\n\t//std::cout << std::endl << TO_RIGHT << \"Press any other key to quit.\";\n\t//PrintAllMovesMadeInOrder();\n\tchar key = 'q';\n\tswitch(key = tolower(key)) {\n\t\tcase 'r':\n\t\t\tReset();\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n\n\n\n\n\n// bot class constructor\nBot::Bot(const std::string &name, const unsigned short &difficulty) noexcept : Player(name), difficulty(difficulty) {\t}\n\n// getter method, returns the difficulty level of the bot\nunsigned short Bot::GetDifficulty() const noexcept {\n\treturn difficulty;\n}\n\n// returns the optimal move the bot can make with the default difficulty level (according to alpha-beta pruning at least)\nstd::string Bot::GetIdealMove(Chess &c) noexcept {\n\treturn root.AlphaBetaRoot(c, difficulty);\n}\n\n// function overload, returns the optimal move the bot can make with the given difficulty level\nstd::string Bot::GetIdealMove(Chess &c, unsigned short difficulty) noexcept {\n\treturn root.AlphaBetaRoot(c, difficulty);\n}\n\n// operator overload for '=='\nbool Bot::operator== (const Bot &b) const noexcept {\n\treturn !name.compare(b.name);\t\n}\n\n\n\n\n\n// player class constructor\nPlayer::Player(const std::string &name) noexcept : name(name) {\t}\n\n// getter method which returns the name of the player\nstd::string Player::GetName() const noexcept {\n\treturn name;\n}\n\n// getter method which returns the score of the player\nunsigned short Player::GetScore() const noexcept {\n\treturn score;\n}\n\n// getter method which returns whether the player can castle or not\nbool Player::GetCastling() const noexcept {\n\treturn castling;\n}\n\n// setter method which sets whether the player can castle or not\nvoid Player::SetCastling(const bool &castling) noexcept {\n\tthis->castling = castling;\n}\n\n// increases the score by an amount of \"inc\" points\nvoid Player::IncreaseScore(const unsigned short &inc) noexcept {\n\tscore += inc;\n}\n\n// resets the score and the ability to castle to their initial values\nvoid Player::Reset() noexcept {\n\tscore = 0;\n\tcastling = true;\n}\n\n// operator overload for '=='\nbool Player::operator== (const Player &p) const noexcept {\n\treturn !name.compare(p.name);\n}\n\n\n\n\n\n\n// creates a subtree which contains all possible moves the player can make\nvoid PathNode::CreateSubtree(Chess &c) noexcept {\n\tauto all_moves = c.AllMoves();\t\t\t\t\t// add all possible moves to the Node's map\n\tfor(auto &move : all_moves) {\n\t\tChess::ChangeToRealCoordinates(move[0], move[1], move[2], move[3]);\n\t\tchild_node_list.emplace(move, PathNode());\n\t}\n}\n\n// returns the maximum score for the minimizing player and the minimum score for the maximizing player in each recursion\nfloat PathNode::AlphaBeta(Chess &c, unsigned short &depth, float alpha, float beta, const bool &maximizing_player, const bool &initial_turn) noexcept {\n\tif(!depth)\n\t\treturn c.EvaluateBoard(initial_turn);\n\tCreateSubtree(c);\n\tfloat points = maximizing_player ? -9999 : 9999;\n\tfor(auto &node : child_node_list) {\t\t\t\t\t\t// 1-0: from, 3-2: to\n\t\tif(c.GetPiece(node.first[2], node.first[3]) == W_KING - 7*c.GetTurn()) {\n\t\t\tchild_node_list.clear();\n\t\t\treturn maximizing_player ? 9999 : -9999;\t\t// if my target piece is king, then it is the most rewarding move\n\t\t}\n\t\tc.MovePiece(node.first[0], node.first[1], node.first[2], node.first[3], false, false);\n\t\tpoints = maximizing_player ? std::max(points, node.second.AlphaBeta(c, --depth, alpha, beta, false, initial_turn))\t\t// recursive alpha-beta algorithm\n\t\t: std::min(points, node.second.AlphaBeta(c, --depth, alpha, beta, true, initial_turn));\n\t\tmaximizing_player ? alpha = std::max(alpha, points) : beta = std::min(beta, points);\n\t\t++depth;\n\t\tc.MovePieceBack(node.first[0], node.first[1], node.first[2], node.first[3]);\n\t\tif(alpha >= beta)\n\t\t\tbreak;\n\t}\n\tchild_node_list.clear();\n\treturn points;\n}\n\n// the main function which returns the optimal move calculated by the alpha-beta algorithm\nstd::string PathNode::AlphaBetaRoot(Chess &c, unsigned short &difficulty) noexcept {\n\tCreateSubtree(c);\n\tstd::vector<std::string> ideal_moves;\n\tfloat max_move_score = -9999;\n\tfor(auto &node : child_node_list) {\n\t\tif(c.GetPiece(node.first[2], node.first[3]) == W_KING - 7*c.GetTurn()) {\n\t\t\tchild_node_list.clear();\n\t\t\treturn node.first;\t\t\t\t\t\t// if my target piece is king, then this move is a game winner so return this move\n\t\t}\n\t\tc.MovePiece(node.first[0], node.first[1], node.first[2], node.first[3], false, false);\n\t\tfloat move_score = node.second.AlphaBeta(c, difficulty, -10000, 10000, false, !c.GetTurn());\n\t\tif(move_score > max_move_score) {\n\t\t\tmax_move_score = move_score;\n\t\t\tideal_moves.clear();\n\t\t\tideal_moves.emplace_back(node.first);\t// add the most rewarding move to the list\n\t\t}\n\t\telse if(move_score == max_move_score)\n\t\t\tideal_moves.emplace_back(node.first);\n\t\tc.MovePieceBack(node.first[0], node.first[1], node.first[2], node.first[3]);\n\t}\n\tchild_node_list.clear();\t\t\t\t\t\t// delete the whole tree\n\tauto move = ideal_moves.cbegin();\n\tadvance(move, GetRandomNumber<unsigned short>(0, ideal_moves.size()-1));\n\treturn *move;\n}\n\n\n\nint main(){\n\n    \n    std::string s1,s2;\n   \n    int i = 0;\n\tChess c(\"0\", 2, \"1\", 2);\n\t\n    std::cin >> s1 >> s2;\n\tif(s1 == \"-1\"){\n\t\twhile(c.BotsTurn(s1,s2)){\n\t\t\tstd::cout << s1 <<\" \" << s2<<std::endl;\n\t\t\tstd::cin >> s1 >> s2;  \n\t\t\n\t\t\tc.PlayersTurn(s1,s2);\n\t\t\t\n\t\t\n\t\t};\n\t}else{\n\t\twhile(c.PlayersTurn(s1,s2)){\n\t\t\t\n\t\t\tc.BotsTurn(s1,s2);\n\t\t\t\n\t\t\tstd::cout << s1 <<\" \" << s2<<std::endl;\n\t\t\tstd::cin >> s1 >> s2;  \n\t\t};\n\t}\n    \n    \n    return 0;\n}";

    private readonly string chess_bot3_cpp =
        "\n\n#define BOARD_SIZE 8\n#define BOX_WIDTH 10\n#define DOWN 3\n#define RIGHT 10\n#define TO_DOWN std::string(DOWN, '\\n')\n#define TO_RIGHT std::string(RIGHT, ' ')\n#define CLEAR_LINE std::string(100, ' ')\n#define MOVES_PER_LINE 5\n\n#define AGAINST_BOT true\t\t\t// if true then it's ? vs bot, if false then it's player vs player\n#define TWO_BOTS true\t\t\t\t// assuming AGAINST_BOT is true, if true then it's bot vs bot, if false then it's player vs bot\n#define BOT_IS_WHITE false\t\t\t// assuming AGAINST_BOT is true and TWO_BOTS is false, if true then the bot is team white, black otherwise\n#define WHITE_BOT_RANDOM true\t\t// if true the white bot returns random moves, if false the white bot returns smart moves generated by minimax algorithm\n#define BLACK_BOT_RANDOM false\t\t// if true the black bot returns random moves, if false the black bot returns smart moves generated by minimax algorithm\n#define WHITE_BOT_DIFFICULTY 1\t\t// the tree depth of decision tree of the bot, which is also correlated to the bot's difficulty (aka chess IQ)\n#define BLACK_BOT_DIFFICULTY 1\t\t// 1: easy, 2: medium, 3: hard\n\n// types of chess pieces\ntypedef enum {\n\tB_KING = -6, B_QUEEN, B_BISHOP, B_KNIGHT, B_ROOK, B_PAWN, EMPTY,\n\tW_KING, W_QUEEN, W_BISHOP, W_KNIGHT, W_ROOK, W_PAWN\n} ChessPieces;\n\n// types of player moves\ntypedef enum {\n\tNORMAL, CASTLING, PROMOTION, EN_PASSANT\n} Moves;\n\n// possible options on how the game can end\ntypedef enum {\n\tCHECKMATE, FIFTY_MOVES, THREEFOLD_REP, QUIT\n} Endgame;\n\n// starting position of the board\nconst char STARTING_BOARD[BOARD_SIZE][BOARD_SIZE] = {{B_ROOK, B_KNIGHT, B_BISHOP, B_QUEEN, B_KING, B_BISHOP, B_KNIGHT, B_ROOK},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN, B_PAWN},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN, W_PAWN},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{W_ROOK, W_KNIGHT, W_BISHOP, W_QUEEN, W_KING, W_BISHOP, W_KNIGHT, W_ROOK}};\n\nclass Player;\nclass PathNode;\nclass Bot;\nclass Chess;\n\n#include <string>\n#include <forward_list>\n#include <vector>\n#include <map>\n#include <iostream>\n#include <algorithm>\n\n\n\n\n// player class declaration\nclass Player {\nprotected:\n\tstd::string name;\t\t\t// name of the player\n\tunsigned short score = 0;\t// score of the player\n\tbool castling = true;\t\t// if true the player can castle, if false the player cannot castle anymore during the game\npublic:\n\tPlayer(const std::string &name) noexcept;\n\tstd::string GetName() const noexcept;\n\tunsigned short GetScore() const noexcept;\n\tbool GetCastling() const noexcept;\n\tvoid SetCastling(const bool &castling) noexcept;\n\tvoid IncreaseScore(const unsigned short &inc) noexcept;\n\tvoid Reset() noexcept;\n\tbool operator== (const Player &p) const noexcept;\n};\n\n// path node class declaration\nclass PathNode {\nprivate:\n\tstd::map<std::string, PathNode> child_node_list;\t// a map where the key (string) corresponds to the player's move and value corresponds to another node, which makes a decision tree\n\tvoid CreateSubtree(Chess &c) noexcept;\n\tfloat AlphaBeta(Chess &c, unsigned short &depth, float alpha, float beta, const bool &maximizing_player, const bool &initial_turn) noexcept;\npublic:\n\tstd::string AlphaBetaRoot(Chess &c, unsigned short &difficulty) noexcept;\n};\n\n// bot class declaration, which inherits from player class\nclass Bot : public Player {\nprivate:\n\tPathNode root;\t\t\t\t\t// the root node of the bot's decision tree\n\tunsigned short difficulty;\t\t// the depth of the bot's decision tree\npublic:\n\tBot(const std::string &name, const unsigned short &difficulty) noexcept;\n\tunsigned short GetDifficulty() const noexcept;\n\tstd::string GetIdealMove(Chess &c) noexcept;\n\tstd::string GetIdealMove(Chess &c, unsigned short difficulty) noexcept;\n\tbool operator== (const Bot &b) const noexcept;\n};\n\n// chess class declaration\nclass Chess {\nprivate:\n\tchar board[BOARD_SIZE][BOARD_SIZE];\t\t// game board\n\tBot white, black;\t\t\t\t\t\t// teams\n\tstd::vector<std::pair<Moves, std::string>> all_game_moves;\t\t// a record which contains all the moves played throughout the game in chronological order\n\tbool whites_turn = true;\t\t\t\t// if true then it's team white's turn, if false then it's team black's turn\n\tunsigned short moves_after_last_pawn_move_or_capture = 0;\t\t// number of moves played after a pawn moved or a capture happened\n\tstatic bool WithinBounds(const short &coord) noexcept;\n\tstatic void ChangeToString(char &x1, char &y1, char &x2, char &y2) noexcept;\n\tstatic std::string ToString(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tstatic std::string PieceNameToString(const char &piece) noexcept;\n\tstatic float EvaluatePiece(const char &piece) noexcept;\n\tstatic void ClearAllMoves(const unsigned short &n) noexcept;\n\tstatic void PrintSeparator(const char &ch) noexcept;\n\tstatic void CopyBoard(const char from[BOARD_SIZE][BOARD_SIZE], char to[BOARD_SIZE][BOARD_SIZE]) noexcept;\n\tstatic bool AreBoardsEqual(const char board1[BOARD_SIZE][BOARD_SIZE], const char board2[BOARD_SIZE][BOARD_SIZE]) noexcept;\n\tstatic bool CanMovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const std::forward_list<std::string> &all_moves) noexcept;\n\tBot& GetCurrentPlayer() noexcept;\n\tBot GetCurrentPlayerConst() const noexcept;\n\tBot& GetOtherPlayer() noexcept;\n\tBot GetOtherPlayerConst() const noexcept;\n\tvoid ChangeTurn() noexcept;\n\tvoid AppendToAllGameMoves(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tvoid Reset() noexcept;\n\tvoid CheckCoordinates(const short &x, const short &y, const std::string &func_name) const noexcept(false);\n\tbool EndGameText(const unsigned short &n, const Endgame &end_game) const noexcept;\n\tshort GetEnPassant(const short &x, const short &y) const noexcept;\n\ttemplate<class Iterator> short GetEnPassant(const char board[BOARD_SIZE][BOARD_SIZE], const Iterator &it) const noexcept;\n\tbool ThreefoldRepetition() const noexcept;\n\tbool IsCheck(const bool &turn) const noexcept;\n\tbool IsCheck(std::string &move) noexcept;\n\tstd::forward_list<std::string> PawnMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> RookMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> KnightMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> BishopMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> QueenMoves(const short &x, const short &y) const noexcept;\n\tstd::forward_list<std::string> KingMoves(const short &x, const short &y) const noexcept;\n\tstd::string GetRandomMove() noexcept;\n\tvoid ManuallyPromotePawn(const short &x, const short &y) noexcept;\n\tvoid UpdateBoard(const short &x, const short &y) const noexcept;\n\tvoid UpdateScore(const Bot &p) const noexcept;\n\tfloat EvaluatePosition(const short &x, const short &y) const noexcept;\n\tvoid PrintAllMovesMadeInOrder() const noexcept;\n\t\npublic:\n    bool CheckEndgame(const unsigned short &n = 0) noexcept;\n\tChess(const std::string &player1, const unsigned short &difficulty1, const std::string &player2, const unsigned short &difficulty2) noexcept;\n\tstatic void ChangeToRealCoordinates(char &x1, char &y1, char &x2, char &y2) noexcept;\n\tchar GetPiece(const short &x, const short &y) const noexcept;\n\tbool GetTurn() const noexcept;\n\tstd::forward_list<std::string> AllMoves() noexcept;\n\tvoid MovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const bool &manual_promotion, const bool &update_board) noexcept;\n\tvoid MovePieceBack(const short &x1, const short &y1, const short &x2, const short &y2) noexcept;\n\tfloat EvaluateBoard(const bool &turn) const noexcept;\n\tvoid PrintBoard() const noexcept;\n\tbool PlayersTurn(std::string s1,std::string s2) noexcept;\n\tbool BotsTurn(std::string &s1, std::string &s2) noexcept;\n\tbool GameOver() noexcept;\n    std::string GetWinner();\n};\n\n// other function declarations\n\nstd::string ToLowerString(std::string s) noexcept;\ntemplate<class T> T GetRandomNumber(const T &min, const T &max) noexcept;\n\t//CHESS_H\n\n\n// function definitions\n\n// moves the cursor to a different (x, y) location on the terminal\n\n\n// returns the given string in lowercase\nstd::string ToLowerString(std::string s) noexcept {\n\ttransform(s.begin(), s.end(), s.begin(), [](const unsigned char &c){ return tolower(c); });\n\treturn s;\n}\n\n// returns a random number between \"min\" and \"max\"\ntemplate<class T> T GetRandomNumber(const T &min, const T &max) noexcept {\n\treturn min + T(static_cast<double>(rand()) / static_cast<double>(RAND_MAX+1.0) * (max-min+1));\n}\n\n\n\n// chess class implementation\n std::string Chess::GetWinner(){\n    return this->GetOtherPlayerConst().GetName();\n }\n// constructor of chess class\nChess::Chess(const std::string &player1, const unsigned short &difficulty1, const std::string &player2, const unsigned short &difficulty2) noexcept\n: white(player1, difficulty1), black(player2, difficulty2) {\n\tCopyBoard(STARTING_BOARD, board);\n}\n\n// checks whether the given coordinate is within board boundaries or not\nbool Chess::WithinBounds(const short &coord) noexcept {\n\treturn coord>=0 && coord<BOARD_SIZE;\n}\n\n// changes the given board coordinates from ASCII to numerical, e.g. ('d', '3') -> (3, 5)\nvoid Chess::ChangeToRealCoordinates(char &x1, char &y1, char &x2, char &y2) noexcept {\n\tx1 -= 'a', x2 -= 'a';\n\ty1 = '8'-y1, y2 = '8'-y2;\n}\n\n// changes the given board coordinates from numerical to ASCII, e.g. (3, 5) -> ('d', '3')\nvoid Chess::ChangeToString(char &x1, char &y1, char &x2, char &y2) noexcept {\n\tx1 += 'a', x2 += 'a';\n\ty1 = '8'-y1, y2 = '8'-y2;\n}\n\n// returns the given numerical board coordinates as a string\nstd::string Chess::ToString(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\treturn {static_cast<char>(x1+'a'), static_cast<char>('8'-y1), static_cast<char>(x2+'a'), static_cast<char>('8'-y2)};\n}\n\n// returns the name that is displayed on the terminal for the given piece\nstd::string Chess::PieceNameToString(const char &piece) noexcept {\n\tswitch(piece) {\n\t\tcase W_PAWN:\treturn \"W_PAWN\";\n\t\tcase B_PAWN:\treturn \"B_PAWN\";\n\t\tcase W_ROOK:\treturn \"W_ROOK\";\n\t\tcase B_ROOK:\treturn \"B_ROOK\";\n\t\tcase W_KNIGHT:\treturn \"W_KNIGHT\";\n\t\tcase B_KNIGHT:\treturn \"B_KNIGHT\";\n\t\tcase W_BISHOP:\treturn \"W_BISHOP\";\n\t\tcase B_BISHOP:\treturn \"B_BISHOP\";\n\t\tcase W_QUEEN:\treturn \"W_QUEEN\";\n\t\tcase B_QUEEN:\treturn \"B_QUEEN\";\n\t\tcase W_KING:\treturn \"W_KING\";\n\t\tcase B_KING:\treturn \"B_KING\";\n\t\tdefault:\t\treturn \"\";\n\t}\n}\n\n// returns the worth of the given piece in terms of points\nfloat Chess::EvaluatePiece(const char &piece) noexcept {\n\tswitch(piece) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\treturn 10;\t\t// pawn: 10 points\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\treturn 50;\t\t// rook: 50 points\n\t\tcase W_KNIGHT:\n\t\tcase B_KNIGHT:\n\t\tcase W_BISHOP:\n\t\tcase B_BISHOP:\treturn 30;\t\t// knight and bishop: 30 points\n\t\tcase W_QUEEN:\n\t\tcase B_QUEEN:\treturn 90;\t\t// queen: 90 points\n\t\tcase W_KING:\n\t\tcase B_KING:\treturn 900;\t\t// king: 900 points, but you can assume it is infinite\n\t\tdefault:\t\treturn 0;\n\t}\n}\n\n// clears all available moves from the terminal\nvoid Chess::ClearAllMoves(const unsigned short &n) noexcept {\n\n}\n\n// prints the vertical seperators for the game board on the terminal\nvoid Chess::PrintSeparator(const char &ch) noexcept {\n\n}\n\n// copies the board contents of \"from\" to \"to\"\nvoid Chess::CopyBoard(const char from[BOARD_SIZE][BOARD_SIZE], char to[BOARD_SIZE][BOARD_SIZE]) noexcept {\n\tstd::copy(*from, *from + BOARD_SIZE*BOARD_SIZE, *to);\n}\n\n// checks whether the board positions of the given two boards are equal or not\nbool Chess::AreBoardsEqual(const char board1[BOARD_SIZE][BOARD_SIZE], const char board2[BOARD_SIZE][BOARD_SIZE]) noexcept {\n\treturn std::equal(*board1, *board1 + BOARD_SIZE*BOARD_SIZE, *board2);\n}\n\nbool Chess::CanMovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const std::forward_list<std::string> &all_moves) noexcept {\n\treturn std::find(all_moves.cbegin(), all_moves.cend(), ToString(x1, y1, x2, y2)) != all_moves.cend();\n}\n\n// getter method, returns the piece located in the given x and y coordinates\nchar Chess::GetPiece(const short &x, const short &y) const noexcept {\n//\tCheckCoordinates(x, y, \"GetPiece\");\n\treturn board[y][x];\n}\n\n// getter method, returns whether it's team white's turn or not\nbool Chess::GetTurn() const noexcept {\n\treturn whites_turn;\n}\n\n// returns a reference to the player object\nBot& Chess::GetCurrentPlayer() noexcept {\n\treturn whites_turn ? white : black;\n}\n\n// returns a copy of the player object\nBot Chess::GetCurrentPlayerConst() const noexcept {\n\treturn whites_turn ? white : black;\n}\n\n// returns a reference to the player object\nBot& Chess::GetOtherPlayer() noexcept {\n\treturn whites_turn ? black : white;\n}\n\n// returns a copy of the player object\nBot Chess::GetOtherPlayerConst() const noexcept {\n\treturn whites_turn ? black : white;\n}\n\n// changes whose turn it is so the other player can make its move\nvoid Chess::ChangeTurn() noexcept {\n\twhites_turn = !whites_turn;\n}\n\n// appends the last made game move to \"all_game_moves\" list\nvoid Chess::AppendToAllGameMoves(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\tif(GetCurrentPlayerConst().GetCastling() && (board[y1][x1] == B_KING + 7*whites_turn) && (x2 == 2 || x2 == 6))\n\t\tall_game_moves.emplace_back(CASTLING, std::string(1, x2));\n\telse\n\t\tall_game_moves.emplace_back(NORMAL, ToString(x1, y1, x2, y2) + board[y1][x1] + board[y2][x2]);\n}\n\n// resets the game, everything is back to its default value\nvoid Chess::Reset() noexcept {\n\tCopyBoard(STARTING_BOARD, board);\n\twhite.Reset();\n\tblack.Reset();\n\tall_game_moves.clear();\n\twhites_turn = true;\n\tmoves_after_last_pawn_move_or_capture = 0;\n\tsystem(\"cls\");\n}\n\n// a function for exception handling, checks whether the given coordinates is within board boundaries or not\nvoid Chess::CheckCoordinates(const short &x, const short &y, const std::string &func_name) const noexcept(false) {\n\ttry {\n\t\tif(!WithinBounds(x))\t\tthrow x;\n\t\tif(!WithinBounds(y))\t\tthrow y;\n\t}\n\tcatch(const short &coord) {\n\t\tstd::cerr << std::endl << std::endl << TO_RIGHT << \"!ERROR!\\t\\tInvalid coordinate: '\" << coord << \"'.\\t\\t!ERROR!\";\n\t\tstd::cerr << std::endl << TO_RIGHT << \"      \\t\\tException occurred in \\\"\" << func_name << \"\\\".\";\n\t\tPrintAllMovesMadeInOrder();\n\t\texit(1);\n\t}\n}\n\n// prints game over message to the terminal\nbool Chess::EndGameText(const unsigned short &n, const Endgame &end_game) const noexcept {\n\tClearAllMoves(n);\n\n\tswitch(end_game) {\n\t\tcase CHECKMATE:\n\t\t\tstd::cout << \"!!!Checkmate!!!\" << CLEAR_LINE << std::endl << TO_RIGHT << GetOtherPlayerConst().GetName() << \" wins!\";\n\t\t\treturn true;\n\t\tdefault:\n\t\t\t//Draw!!!\n\t\t\tswitch(end_game) {\n\t\t\t\tcase FIFTY_MOVES:\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\tcase THREEFOLD_REP:\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t}\n}\n\n// returns the x coordinate of the eaten pawn piece\nshort Chess::GetEnPassant(const short &x, const short &y) const noexcept {\n\tif(all_game_moves.empty())\n\t\treturn -1;\n\tif(all_game_moves.back().first != NORMAL)\n\t\treturn -1;\n\tauto last_move = all_game_moves.back().second;\n\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\treturn ((last_move[4] == W_PAWN - 7*whites_turn) && (abs(last_move[0] - x) == 1) && (last_move[3]-last_move[1] == 2*(whites_turn ? 1 : -1)) && (y == 4 - whites_turn)) ? last_move[0] : -1;\n}\n\n// returns the x coordinate of the en passant move\ntemplate<class Iterator> short Chess::GetEnPassant(const char board[BOARD_SIZE][BOARD_SIZE], const Iterator &it) const noexcept {\n\tif(it->first != NORMAL)\n\t\treturn -1;\n\tauto last_move = it->second;\n\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\tfor(short x=0;x<BOARD_SIZE;++x)\n\t\tif(board[3 + whites_turn][x] == W_PAWN - 7*whites_turn)\n\t\t\tif((last_move[4] == B_PAWN + 7*whites_turn) && (abs(last_move[0] - x) == 1) && (last_move[3] - last_move[1] == 2*(whites_turn ? -1 : 1)))\n\t\t\t\treturn last_move[0];\n\treturn -1;\n}\n\n// returns true if threefold repetition occurs, false otherwise\nbool Chess::ThreefoldRepetition() const noexcept {\n\tstatic char prev_board[BOARD_SIZE][BOARD_SIZE];\n\tCopyBoard(board, prev_board);\n\tunsigned short position_count = 1;\n\tauto it = all_game_moves.crbegin();\n\tauto last_move = it->second;\n\twhile(true) {\n\t\tfor(unsigned short i=0;i<2;++i)\t{\n\t\t\tswitch(it->first) {\n\t\t\t\tcase CASTLING:\n\t\t\t\t\treturn false;\t\t// if a pawn has moved or a castling/capture has occured, then that board position is unique and repetition is not possible\n\t\t\t\tdefault:\n\t\t\t\t\tif(last_move[4] == W_PAWN || last_move[4] == B_PAWN || last_move[5] != EMPTY)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tChangeToRealCoordinates(last_move[0], last_move[1], last_move[2], last_move[3]);\n\t\t\t\t\tprev_board[short(last_move[1])][short(last_move[0])] = last_move[4], prev_board[short(last_move[3])][short(last_move[2])] = EMPTY;\n\t\t\t\t\tif(it->first == EN_PASSANT)\n\t\t\t\t\t\tprev_board[short(last_move[1])][short(last_move[2])] = i == whites_turn ? B_PAWN : W_PAWN;\n\t\t\t}\n\t\t\tif((++it) == all_game_moves.crend())\n\t\t\t\treturn false;\n\t\t\tlast_move = it->second;\n\t\t}\n\t\tif(AreBoardsEqual(prev_board, board))\t\t// check for castling and en passant in every 2 turns\n\t\t\tif(GetOtherPlayerConst().GetCastling() == (it->first == CASTLING ? false : last_move[6 + (it->first == PROMOTION)]))\n\t\t\t\tif((all_game_moves.size() > 1 ? GetEnPassant(board, prev(all_game_moves.cend(), 2)) : -1)\n\t\t\t\t== (next(it) == all_game_moves.crend() ? -1 : GetEnPassant(prev_board, next(it))))\n\t\t\t\t\tif((++position_count) == 3)\n\t\t\t\t\t\treturn true;\n\t}\n}\n\n// returns true if the player's king is in check, false otherwise\nbool Chess::IsCheck(const bool &turn) const noexcept {\n\tshort x = -1, y = -1;\n\tfor(short i=0;x==-1;++i)\n\t\tfor(short j=0;j<BOARD_SIZE;++j)\n\t\t\tif(board[j][i] == B_KING + 7*turn) {\n\t\t\t\tx = i, y = j;\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(short i=x+1;i<BOARD_SIZE;++i)\t\t\t\t\t\t// check queen and rook\n\t\tif(board[y][i] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[y][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[y][i] != EMPTY)\tbreak;\n\tfor(short i=x-1;i>=0;--i)\n\t\tif(board[y][i] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[y][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[y][i] != EMPTY)\tbreak;\n\tfor(short i=y+1;i<BOARD_SIZE;++i)\n\t\tif(board[i][x] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[i][x] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[i][x] != EMPTY)\tbreak;\n\tfor(short i=y-1;i>=0;--i)\n\t\tif(board[i][x] == W_ROOK - 7*turn)\t\t\treturn true;\n\t\telse if(board[i][x] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[i][x] != EMPTY)\tbreak;\n\tfor(short i=x-1, j=y-1; i>=0 && j>=0; --i, --j)\t\t\t// check queen and bishop\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x-1, j=y+1; i>=0 && j<BOARD_SIZE; --i, ++j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x+1, j=y-1; i<BOARD_SIZE && j>=0; ++i, --j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x+1, j=y+1; i<BOARD_SIZE && j<BOARD_SIZE; ++i, ++j)\n\t\tif(board[j][i] == W_BISHOP - 7*turn)\t\treturn true;\n\t\telse if(board[j][i] == W_QUEEN - 7*turn)\treturn true;\n\t\telse if(board[j][i] != EMPTY)\tbreak;\n\tfor(short i=x-1;i<x+2;++i)\t\t\t\t\t\t\t\t// check king\n\t\tfor(short j=y-1;j<y+2;++j)\n\t\t\tif((board[j][i] == W_KING - 7*turn) && WithinBounds(i) && WithinBounds(j))\t\t\treturn true;\n\tif((board[y-1][x-2] == W_KNIGHT - 7*turn) && (y > 0) && (x > 1))\t\t\t\t\t\t\treturn true;\t// check knight\n\telse if((board[y-1][x+2] == W_KNIGHT - 7*turn) && (y > 0) && (x < BOARD_SIZE-2))\t\t\treturn true;\n\telse if((board[y+1][x-2] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-1) && (x > 1))\t\t\treturn true;\n\telse if((board[y+1][x+2] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-1) && (x < BOARD_SIZE-2))\treturn true;\n\telse if((board[y-2][x-1] == W_KNIGHT - 7*turn) && (y > 1) && (x > 0))\t\t\t\t\t\treturn true;\n\telse if((board[y-2][x+1] == W_KNIGHT - 7*turn) && (y > 1) && (x < BOARD_SIZE-1))\t\t\treturn true;\n\telse if((board[y+2][x-1] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-2) && (x > 0))\t\t\treturn true;\n\telse if((board[y+2][x+1] == W_KNIGHT - 7*turn) && (y < BOARD_SIZE-2) && (x < BOARD_SIZE-1))\treturn true;\n\telse if((board[y + (turn ? -1 : 1)][x+1] == W_PAWN - 7*turn) && (x < BOARD_SIZE-1))\t\t\treturn true;\t// check pawn\n\telse if((board[y + (turn ? -1 : 1)][x-1] == W_PAWN - 7*turn) && (x > 0))\t\t\t\t\treturn true;\n\treturn false;\n}\n\n// function overload, returns true if the player's king is in check, false otherwise\nbool Chess::IsCheck(std::string &move) noexcept {\n\tChangeToRealCoordinates(move[0], move[1], move[2], move[3]);\n\tMovePiece(move[0], move[1], move[2], move[3], false, false);\n\tconst bool &is_check = IsCheck(!whites_turn);\n\tMovePieceBack(move[0], move[1], move[2], move[3]);\n\tChangeToString(move[0], move[1], move[2], move[3]);\n\treturn is_check;\n}\n\n// returns a list of all possible moves the pawn located in (x, y) can make\nstd::forward_list<std::string> Chess::PawnMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tconst short &inc = whites_turn ? -1 : 1;\n\tstd::forward_list<std::string> all_moves;\n\tif(board[y+inc][x] == EMPTY) {\n\t\tall_moves.emplace_front(ToString(x, y, x, y+inc));\t\t\t\t// 1 square forward\n\t\tif((y == 1 + 5*whites_turn) && (board[y + 2*inc][x] == EMPTY))\n\t\t\tall_moves.emplace_front(ToString(x, y, x, y + 2*inc));\t\t// 2 squares forward\n\t}\n\tif(GetEnPassant(x, y) != -1)\n\t\tall_moves.emplace_front(ToString(x, y, GetEnPassant(x, y), y+inc));\n\tif(IsValid(board[y+inc][x+1]) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y+inc));\t\t// diagonal attack moves\n\tif(IsValid(board[y+inc][x-1]) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y+inc));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the rook located in (x, y) can make\nstd::forward_list<std::string> Chess::RookMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x+1;i<BOARD_SIZE;++i)\t\t\t// right\n\t\tif(board[y][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\telse {\n\t\t\tif(IsValid(board[y][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x-1;i>=0;--i)\t\t\t\t\t// left\n\t\tif(board[y][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\telse {\n\t\t\tif(IsValid(board[y][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, y));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=y+1;i<BOARD_SIZE;++i)\t\t\t// down\n\t\tif(board[i][x] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\telse {\n\t\t\tif(IsValid(board[i][x]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=y-1;i>=0;--i)\t\t\t\t\t// up\n\t\tif(board[i][x] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\telse {\n\t\t\tif(IsValid(board[i][x]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, x, i));\n\t\t\tbreak;\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the knight located in (x, y) can make\nstd::forward_list<std::string> Chess::KnightMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch <= 0; } : [](const char &ch){ return ch >= 0; };\n\tstd::forward_list<std::string> all_moves;\n\tif(IsValid(board[y-1][x-2]) && (y > 0) && (x > 1))\n\t\tall_moves.emplace_front(ToString(x, y, x-2, y-1));\n\tif(IsValid(board[y-1][x+2]) && (y > 0) && (x < BOARD_SIZE-2))\n\t\tall_moves.emplace_front(ToString(x, y, x+2, y-1));\n\tif(IsValid(board[y+1][x-2]) && (y < BOARD_SIZE-1) && (x > 1))\n\t\tall_moves.emplace_front(ToString(x, y, x-2, y+1));\n\tif(IsValid(board[y+1][x+2]) && (y < BOARD_SIZE-1) && (x < BOARD_SIZE-2))\n\t\tall_moves.emplace_front(ToString(x, y, x+2, y+1));\n\tif(IsValid(board[y-2][x-1]) && (y > 1) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y-2));\n\tif(IsValid(board[y-2][x+1]) && (y > 1) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y-2));\n\tif(IsValid(board[y+2][x-1]) && (y < BOARD_SIZE-2) && (x > 0))\n\t\tall_moves.emplace_front(ToString(x, y, x-1, y+2));\n\tif(IsValid(board[y+2][x+1]) && (y < BOARD_SIZE-2) && (x < BOARD_SIZE-1))\n\t\tall_moves.emplace_front(ToString(x, y, x+1, y+2));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the bishop located in (x, y) can make\nstd::forward_list<std::string> Chess::BishopMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch < 0; } : [](const char &ch){ return ch > 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x-1, j=y-1; i>=0 && j>=0; --i, --j)\t\t\t\t\t\t// upper left diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x-1, j=y+1; i>=0 && j<BOARD_SIZE; --i, ++j)\t\t\t\t// lower left diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x+1, j=y-1; i<BOARD_SIZE && j>=0; ++i, --j)\t\t\t\t// upper right diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\tfor(short i=x+1, j=y+1; i<BOARD_SIZE && j<BOARD_SIZE; ++i, ++j)\t\t// lower right diagonal\n\t\tif(board[j][i] == EMPTY)\n\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\telse {\n\t\t\tif(IsValid(board[j][i]))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\t\t\tbreak;\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the queen located in (x, y) can make\nstd::forward_list<std::string> Chess::QueenMoves(const short &x, const short &y) const noexcept {\n\tauto all_moves = RookMoves(x, y);\t\t\t// queen = rook + bishop\n\tall_moves.merge(BishopMoves(x, y));\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the king located in (x, y) can make\nstd::forward_list<std::string> Chess::KingMoves(const short &x, const short &y) const noexcept {\n\tconst auto &IsValid = whites_turn ? [](const char &ch){ return ch <= 0; } : [](const char &ch){ return ch >= 0; };\n\tstd::forward_list<std::string> all_moves;\n\tfor(short i=x-1;i<x+2;++i)\t\t// add moves within 1 square reach\n\t\tfor(short j=y-1;j<y+2;++j)\n\t\t\tif(IsValid(board[j][i]) && WithinBounds(i) && WithinBounds(j))\n\t\t\t\tall_moves.emplace_front(ToString(x, y, i, j));\n\tif(GetCurrentPlayerConst().GetCastling())\t\t// add castling moves if castling is possible\n\t\tif(!IsCheck(whites_turn)) {\n\t\t\tconst short &line = (BOARD_SIZE-1)*whites_turn;\n\t\t\tif((board[line][0] == B_ROOK + 7*whites_turn) && board[line][1] == EMPTY && board[line][2] == EMPTY && board[line][3] == EMPTY)\n\t\t\t\tall_moves.emplace_front(ToString(4, line, 2, line));\t// long castling\n\t\t\telse if((board[line][7] == B_ROOK + 7*whites_turn) && board[line][5] == EMPTY && board[line][6] == EMPTY)\n\t\t\t\tall_moves.emplace_front(ToString(4, line, 6, line));\t// short castling\n\t\t}\n\treturn all_moves;\n}\n\n// returns a list of all possible moves the player can make\nstd::forward_list<std::string> Chess::AllMoves() noexcept {\n\tstd::forward_list<std::string> all_moves;\n\tfor(short y=0;y<BOARD_SIZE;++y)\n\t\tfor(short x=0;x<BOARD_SIZE;++x) {\n\t\t\tif((board[y][x] < 0) == whites_turn)\n\t\t\t\tcontinue;\n\t\t\tswitch(board[y][x]) {\n\t\t\t\tcase W_PAWN:\n\t\t\t\tcase B_PAWN:\n\t\t\t\t\tall_moves.merge(PawnMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_ROOK:\n\t\t\t\tcase B_ROOK:\n\t\t\t\t\tall_moves.merge(RookMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_KNIGHT:\n\t\t\t\tcase B_KNIGHT:\n\t\t\t\t\tall_moves.merge(KnightMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_BISHOP:\n\t\t\t\tcase B_BISHOP:\n\t\t\t\t\tall_moves.merge(BishopMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_QUEEN:\n\t\t\t\tcase B_QUEEN:\n\t\t\t\t\tall_moves.merge(QueenMoves(x, y));\n\t\t\t\t\tbreak;\n\t\t\t\tcase W_KING:\n\t\t\t\tcase B_KING:\n\t\t\t\t\tall_moves.merge(KingMoves(x, y));\n\t\t\t}\n\t\t}\n\tfor(auto it = all_moves.begin(), prev = all_moves.before_begin(); it != all_moves.cend();)\t\t// if the possible move makes me checkmate after the opponent's turn, remove it from the list\n\t\tif(IsCheck(*it))\n\t\t\tit = all_moves.erase_after(prev);\n\t\telse\n\t\t\t++it, ++prev;\n\treturn all_moves;\n}\n\n// returns a random move the player can make\nstd::string Chess::GetRandomMove() noexcept {\n\tauto all_moves = AllMoves();\n\tauto move = all_moves.begin();\n\tadvance(move, GetRandomNumber<unsigned short>(0, distance(all_moves.cbegin(), all_moves.cend()) - 1));\n\tChangeToRealCoordinates((*move)[0], (*move)[1], (*move)[2], (*move)[3]);\n\treturn *move;\n}\n\n// asks the player it's choice of promotion, then promotes the pawn to the desired piece\nvoid Chess::ManuallyPromotePawn(const short &x, const short &y) noexcept {\n\t\n\tchar key = 'q';\n\t\n\t\tswitch(key = tolower(key)) {\n\t\t\tcase 'r':\tboard[y][x] = whites_turn ? W_ROOK : B_ROOK;\t\treturn;\n\t\t\tcase 'k':\tboard[y][x] = whites_turn ? W_KNIGHT : B_KNIGHT;\treturn;\n\t\t\tcase 'b':\tboard[y][x] = whites_turn ? W_BISHOP : B_BISHOP;\treturn;\n\t\t\tcase 'q':\tboard[y][x] = whites_turn ? W_QUEEN : B_QUEEN;\t\treturn;\n\t\t\n\t\t}\n}\n\n// moves the piece from (x1, y1) to (x2, y2)\nvoid Chess::MovePiece(const short &x1, const short &y1, const short &x2, const short &y2, const bool &manual_promotion, const bool &update_board) noexcept {\n//\tCheckCoordinates(x1, y1, \"MovePiece\");\n//\tCheckCoordinates(x2, y2, \"MovePiece\");\n\tAppendToAllGameMoves(x1, y1, x2, y2);\t\t// similar to FEN notation but not really, the starting and ending points of the moving piece, promoted piece if there is promotion and ability to do castling\n\tswitch(board[y1][x1]) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\n\t\t\tif(y2 == ((BOARD_SIZE-1) * !whites_turn)) {\t\t\t// check for castling, promotion or en passant\n\t\t\t\tif(manual_promotion) {\n\t\t\t\t\tManuallyPromotePawn(x1, y1);\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if(whites_turn ? WHITE_BOT_RANDOM : BLACK_BOT_RANDOM)\n\t\t\t\t\tboard[y1][x1] = (whites_turn ? 1 : -1) * GetRandomNumber(2, 5);\n\t\t\t\telse\n\t\t\t\t\tboard[y1][x1] = whites_turn ? W_QUEEN : B_QUEEN;\n\t\t\t\tall_game_moves.back().first = PROMOTION;\n\t\t\t\tall_game_moves.back().second.push_back(board[y1][x1]);\n\t\t\t}\n\t\t\telse if(x1 != x2 && board[y2][x2] == EMPTY) {\n\t\t\t\tboard[y1][x2] = EMPTY;\n\t\t\t\tif(update_board) {\n\t\t\t\t\tGetCurrentPlayer().IncreaseScore(EvaluatePiece(W_PAWN));\n\t\t\t\t\tUpdateScore(GetCurrentPlayerConst());\n\t\t\t\t\tUpdateBoard(x2, y1);\n\t\t\t\t}\n\t\t\t\tall_game_moves.back().first = EN_PASSANT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase W_KING:\n\t\tcase B_KING:\n\t\t\tif(GetCurrentPlayerConst().GetCastling()) {\n\t\t\t\tconst short &line = (BOARD_SIZE-1) * whites_turn;\n\t\t\t\tswitch(x2) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tboard[line][3] = board[line][0], board[line][0] = EMPTY;\n\t\t\t\t\t\tif(update_board) {\n\t\t\t\t\t\t\tUpdateBoard(0, line);\n\t\t\t\t\t\t\tUpdateBoard(3, line);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tboard[line][5] = board[line][7], board[line][7] = EMPTY;\n\t\t\t\t\t\tif(update_board) {\n\t\t\t\t\t\t\tUpdateBoard(7, line);\n\t\t\t\t\t\t\tUpdateBoard(5, line);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\n\t\t\tGetCurrentPlayer().SetCastling(false);\n\t}\n\tif(all_game_moves.back().first != CASTLING)\t\t\t\tall_game_moves.back().second.push_back(GetCurrentPlayerConst().GetCastling());\n\tboard[y2][x2] = board[y1][x1], board[y1][x1] = EMPTY;\n\tif(update_board) {\n\t\tif(all_game_moves.back().first != CASTLING)\n\t\t\tif(all_game_moves.back().second[5] != EMPTY) {\n\t\t\t\tGetCurrentPlayer().IncreaseScore(EvaluatePiece(all_game_moves.back().second[5]));\n\t\t\t\tUpdateScore(GetCurrentPlayerConst());\n\t\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// the piece is eaten\n\t\t\t}\n\t\tUpdateBoard(x1, y1);\n\t\tUpdateBoard(x2, y2);\n\t}\n\tChangeTurn();\t\t// it's the opponent's turn\n}\n\n// undoes the move from (x1,y1) to (x2,y2), the opposite of the \"MovePiece\" function\nvoid Chess::MovePieceBack(const short &x1, const short &y1, const short &x2, const short &y2) noexcept {\n\tChangeTurn();\n\tboard[y1][x1] = board[y2][x2], board[y2][x2] = all_game_moves.back().first == CASTLING ? static_cast<char>(EMPTY) : all_game_moves.back().second[5];\n\tswitch(board[y1][x1]) {\n\t\tcase W_PAWN:\n\t\tcase B_PAWN:\n\t\t\tif(x1 != x2 && board[y2][x2] == EMPTY)\n\t\t\t\tboard[y1][x2] = whites_turn ? B_PAWN : W_PAWN;\n\t\t\tbreak;\n\t\tcase W_ROOK:\n\t\tcase B_ROOK:\n\t\t\tif(prev(all_game_moves.cend(), 3)->first != CASTLING)\n\t\t\t\tif(prev(all_game_moves.cend(), 3)->second[6 + (prev(all_game_moves.cend(), 3)->first == PROMOTION)])\n\t\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t\t\tbreak;\n\t\tcase W_QUEEN:\n\t\tcase B_QUEEN:\n\t\t\tif(all_game_moves.back().first == PROMOTION)\n\t\t\t\tboard[y1][x1] = whites_turn ? W_PAWN : B_PAWN;\n\t\t\tbreak;\n\t\tcase W_KING:\n\t\tcase B_KING:\n\t\t\tif(all_game_moves.back().first == CASTLING) {\n\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t\t\t\tconst short line = (BOARD_SIZE-1) * whites_turn;\n\t\t\t\tswitch(x2) {\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tboard[line][0] = board[line][3], board[line][3] = EMPTY;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tboard[line][7] = board[line][5], board[line][5] = EMPTY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(prev(all_game_moves.cend(), 3)->first != CASTLING)\n\t\t\t\tif(prev(all_game_moves.cend(), 3)->second[6 + (prev(all_game_moves.cend(), 3)->first == PROMOTION)])\n\t\t\t\t\tGetCurrentPlayer().SetCastling(true);\n\t}\n\tall_game_moves.pop_back();\n}\n\n// updates the board display on the terminal\nvoid Chess::UpdateBoard(const short &x, const short &y) const noexcept {\n\tconst unsigned short &diff = BOX_WIDTH - PieceNameToString(board[y][x]).length();\n\t\n}\n\n// updates the score display on the terminal\nvoid Chess::UpdateScore(const Bot &p) const noexcept {\n\tconst unsigned short &dx = p==white ? white.GetName().length() + 2 : (BOX_WIDTH+1)*BOARD_SIZE - 5;\n\t\n\n}\n\n// returns the worth of the position of the piece in terms of points\nfloat Chess::EvaluatePosition(const short &x, const short &y) const noexcept {\n\tif(board[y][x] == EMPTY)\n\t\treturn 0;\n\tstatic float PIECE_POS_POINTS[6][BOARD_SIZE][BOARD_SIZE] =\n\t{{{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\t\t// king\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0},\n\t{-2.0, -3.0, -3.0, -4.0, -4.0, -3.0, -3.0, -2.0},\n\t{-1.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -1.0},\n\t{2.0, 2.0, 0.0, 0.0, 0.0, 0.0, 2.0, 2.0},\n\t{2.0, 3.0, 1.0, 0.0, 0.0, 1.0, 3.0, 2.0}}\n\t,\n\t{{-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0},\t\t// queen\n\t{-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0},\n\t{-0.5, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5},\n\t{0.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5},\n\t{-1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0}}\n\t,\n\t{{-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0},\t\t// bishop\n\t{-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0},\n\t{-1.0, 0.0, 0.5, 1.0, 1.0, 0.5, 0.0, -1.0},\n\t{-1.0, 0.5, 0.5, 1.0, 1.0, 0.5, 0.5, -1.0},\n\t{-1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, -1.0},\n\t{-1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0},\n\t{-1.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, -1.0},\n\t{-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0}}\n\t,\n\t{{-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0},\t\t// knight\n\t{-4.0, -2.0, 0.0, 0.0, 0.0, 0.0, -2.0, -4.0},\n\t{-3.0, 0.0, 1.0, 1.5, 1.5, 1.0, 0.0, -3.0},\n\t{-3.0, 0.5, 1.5, 2.0, 2.0, 1.5, 0.5, -3.0},\n\t{-3.0, 0.0, 1.5, 2.0, 2.0, 1.5, 0.0, -3.0},\n\t{-3.0, 0.5, 1.0, 1.5, 1.5, 1.0, 0.5, -3.0},\n\t{-4.0, -2.0, 0.0, 0.5, 0.5, 0.0, -2.0, -4.0},\n\t{-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0}}\n\t,\n\t{{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\t\t\t\t// rook\n\t{0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5},\n\t{0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0}}\n\t,\n\t{{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},\t\t\t\t// pawn\n\t{5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0},\n\t{1.0, 1.0, 2.0, 3.0, 3.0, 2.0, 1.0, 1.0},\n\t{0.5, 0.5, 1.0, 2.5, 2.5, 1.0, 0.5, 0.5},\n\t{0.0, 0.0, 0.0, 2.0, 2.0, 0.0, 0.0, 0.0},\n\t{0.5, -0.5, -1.0, 0.0, 0.0, -1.0, -0.5, 0.5},\n\t{0.5, 1.0, 1.0, -2.0, -2.0, 1.0, 1.0, 0.5},\n\t{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}}};\t\t\t\t// returns negative points if the pieces are black, positive points if the pieces are white\n\treturn (board[y][x]<0 ? -1 : 1) * (EvaluatePiece(board[y][x]) + PIECE_POS_POINTS[board[y][x] + 7*(board[y][x]<0) - 1][board[y][x]<0 ? BOARD_SIZE-y-1 : y][x]);\n}\n\n// returns the worth of the board position in terms of points\nfloat Chess::EvaluateBoard(const bool &turn) const noexcept {\n\tfloat total_evaluation = 0.0;\n\tfor(short y=0;y<BOARD_SIZE;++y)\n\t\tfor(short x=0;x<BOARD_SIZE;++x)\n\t\t\ttotal_evaluation += EvaluatePosition(x, y);\n\treturn (turn ? 1 : -1) * total_evaluation;\n}\n\n// prints the game board on the terminal\nvoid Chess::PrintBoard() const noexcept {\n\tstd::cout << TO_DOWN << TO_RIGHT;\n\tfor(short y=0;y<BOARD_SIZE;++y) {\n\t\tPrintSeparator(' ');\n\t\tstd::cout << \"\\b\\b\\b\" << BOARD_SIZE-y << \"  \";\n\t\tfor(short x=0;x<BOARD_SIZE;++x) {\n\t\t\tconst unsigned short &diff = BOX_WIDTH - PieceNameToString(board[y][x]).length();\n\t\t\tstd::cout << std::string(diff/2, ' ') << PieceNameToString(board[y][x]) << std::string(diff/2, ' ');\n\t\t\tif(diff%2)\t\t\t\tstd::cout << \" \";\n\t\t\tif(x < BOARD_SIZE-1)\tstd::cout << \"|\";\n\t\t}\n\t\tif(y < BOARD_SIZE-1) {\n\t\t\tstd::cout << std::endl << TO_RIGHT;\n\t\t\tPrintSeparator('_');\n\t\t}\n\t}\n\tstd::cout << std::endl << TO_RIGHT;\n\tPrintSeparator(' ');\n\tfor(char ch='a';ch<'a'+BOARD_SIZE;++ch)\n\t\tstd::cout << std::string(BOX_WIDTH/2, ' ') << ch << std::string(BOX_WIDTH/2, ' ');\n\tstd::cout << std::endl << std::endl << TO_RIGHT << white.GetName() << \": 0\";\n\tstd::cout << std::string((BOX_WIDTH+1)*BOARD_SIZE - white.GetName().length() - black.GetName().length() - 10, ' ') << black.GetName() << \": 0\";\n\tstd::cout << std::endl << std::endl << TO_RIGHT << white.GetName() << \"'s turn...\";\n\tstd::cout << std::endl << TO_RIGHT << \"Enter move coordinates (x1,y1)->(x2,y2):\";\n\tstd::cout << std::endl << std::endl << TO_RIGHT << \"All possible moves:\" << std::endl;\n}\n\n// after the game is over, prints all moves played throughout the game in chronological order\nvoid Chess::PrintAllMovesMadeInOrder() const noexcept {\n\tstd::cout << std::endl << std::endl << TO_RIGHT << \"All moves made in order:\" << std::endl;\n\tbool turn = true;\n\tfor(const auto &game_move : all_game_moves) {\n\t\tstd::cout << std::endl << TO_RIGHT << (turn ? white : black).GetName() << \": \";\n\t\tswitch(game_move.first) {\n\t\t\tcase CASTLING:\n\t\t\t\tstd::cout << \"castling \" << (game_move.second[0] == 2 ? \"long\" : \"short\");\tbreak;\n\t\t\tdefault:\n\t\t\t\tstd::cout << ToLowerString(PieceNameToString(game_move.second[4])).substr(2) << \" '\" << game_move.second.substr(0, 2) << \"' to \";\n\t\t\t\tif(game_move.second[5] != EMPTY)\n\t\t\t\t\tstd::cout << ToLowerString(PieceNameToString(game_move.second[5])).substr(2) + \" \";\n\t\t\t\tstd::cout << \"'\" << game_move.second.substr(2, 2) << \"'\";\n\t\t\t\tswitch(game_move.first) {\n\t\t\t\t\tcase PROMOTION:\n\t\t\t\t\t\tstd::cout << \" promoted to \" << ToLowerString(PieceNameToString(game_move.second[6])).substr(2);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase EN_PASSANT:\n\t\t\t\t\t\tstd::cout << \" (en passant)\";\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tturn = !turn;\n\t}\n}\n\n// checks if the game is over or not\nbool Chess::CheckEndgame(const unsigned short &n) noexcept {\n\tif(AllMoves().empty()) {\t\t\t// if the opponent has no moves left, then it is checkmate\n\t\tGetOtherPlayer().IncreaseScore(EvaluatePiece(W_KING));\n\t\tUpdateScore(GetOtherPlayerConst());\n\t\treturn EndGameText(n, CHECKMATE);\n\t}\n\telse if(all_game_moves.back().first != CASTLING) {\n\t\tif(all_game_moves.back().second[4] == W_PAWN - 7*whites_turn)\n\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// pawn has moved\n\t\telse if(all_game_moves.back().second[5] != EMPTY)\n\t\t\tmoves_after_last_pawn_move_or_capture = 0;\t\t// capture has occured\n\t\telse if((++moves_after_last_pawn_move_or_capture) == 50)\n\t\t\treturn EndGameText(n, FIFTY_MOVES);\n\t}\n\telse if((++moves_after_last_pawn_move_or_capture) == 50)\n\t\treturn EndGameText(n, FIFTY_MOVES);\n\tif(ThreefoldRepetition())\n\t\treturn EndGameText(n, THREEFOLD_REP);\n\treturn false;\n}\n\n// lists all possible moves, expects player input and plays the given move if it is valid, expects a valid input otherwise\nbool Chess::PlayersTurn(std::string from,std::string to) noexcept {\n\tauto all_moves = AllMoves();\n\tall_moves.sort();\n\tunsigned short i=0;\n\t\n\tif(IsCheck(whites_turn)) {\n\t\t\n\t\ti += 2*MOVES_PER_LINE;\n\t}\n\t\n\twhile(true) {\n\t\t\n\t\t\n\t\tif(!ToLowerString(from).compare(\"quit\"))\n\t\t\treturn EndGameText(i/MOVES_PER_LINE + 1, QUIT);\n\t\tif(!ToLowerString(from).compare(\"exit\"))\n\t\t\treturn EndGameText(i/MOVES_PER_LINE + 1, QUIT);\n\t\t\n\t\tfrom.resize(2);\n\t\tto.resize(2);\n\t\tfrom.shrink_to_fit();\n\t\tto.shrink_to_fit();\n\t\tfrom[0] = tolower(from[0]), to[0] = tolower(to[0]);\n\t\tChangeToRealCoordinates(from[0], from[1], to[0], to[1]);\n       \n\t\tif((from[0]!=to[0] || from[1]!=to[1]) && WithinBounds(from[0]) && WithinBounds(from[1]) && WithinBounds(to[0]) && WithinBounds(to[1])){\n\t\t\tif(CanMovePiece(from[0], from[1], to[0], to[1], all_moves)) {\n\t\t\t\tMovePiece(from[0], from[1], to[0], to[1], true, true);\n\t\t\t\tif(CheckEndgame(i/MOVES_PER_LINE + 1))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\t}else{\n                return false;\n            }\n        }else{\n            return false;\n        }\n\t\t\n\t\t\n\t}\n\t\n\tClearAllMoves(i/MOVES_PER_LINE + 1);\n\t\n\treturn true;\n}\n\n// plays the bots move\nbool Chess::BotsTurn(std::string &s1, std::string &s2) noexcept {\n\tconst auto &move = (whites_turn ? WHITE_BOT_RANDOM : BLACK_BOT_RANDOM) ? GetRandomMove() : GetCurrentPlayer().GetIdealMove(*this);\n\tMovePiece(move[0], move[1], move[2], move[3], false, true);\n\t\n\ts1 = \"  \";\n\ts2 = \"  \";\n\ts1[0] = move[0]+'a';\n\ts1[1] = '8' - move[1];\n\ts2[0] = move[2]+'a';\n\ts2[1] = '8' - move[3];\n\tif(CheckEndgame())\n\t\treturn false;\n\t\n\treturn true;\n}\n\n// prints game over messages and expects user input for another game\nbool Chess::GameOver() noexcept {\n\t//std::cout << std::endl << std::endl << std::endl << TO_RIGHT << \"Press R to play again.\";\n\t//std::cout << std::endl << TO_RIGHT << \"Press any other key to quit.\";\n\t//PrintAllMovesMadeInOrder();\n\tchar key = 'a';\n\tswitch(key = tolower(key)) {\n\t\tcase 'r':\n\t\t\tReset();\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n\n\n\n\n\n// bot class constructor\nBot::Bot(const std::string &name, const unsigned short &difficulty) noexcept : Player(name), difficulty(difficulty) {\t}\n\n// getter method, returns the difficulty level of the bot\nunsigned short Bot::GetDifficulty() const noexcept {\n\treturn difficulty;\n}\n\n// returns the optimal move the bot can make with the default difficulty level (according to alpha-beta pruning at least)\nstd::string Bot::GetIdealMove(Chess &c) noexcept {\n\treturn root.AlphaBetaRoot(c, difficulty);\n}\n\n// function overload, returns the optimal move the bot can make with the given difficulty level\nstd::string Bot::GetIdealMove(Chess &c, unsigned short difficulty) noexcept {\n\treturn root.AlphaBetaRoot(c, difficulty);\n}\n\n// operator overload for '=='\nbool Bot::operator== (const Bot &b) const noexcept {\n\treturn !name.compare(b.name);\t\n}\n\n\n\n\n\n// player class constructor\nPlayer::Player(const std::string &name) noexcept : name(name) {\t}\n\n// getter method which returns the name of the player\nstd::string Player::GetName() const noexcept {\n\treturn name;\n}\n\n// getter method which returns the score of the player\nunsigned short Player::GetScore() const noexcept {\n\treturn score;\n}\n\n// getter method which returns whether the player can castle or not\nbool Player::GetCastling() const noexcept {\n\treturn castling;\n}\n\n// setter method which sets whether the player can castle or not\nvoid Player::SetCastling(const bool &castling) noexcept {\n\tthis->castling = castling;\n}\n\n// increases the score by an amount of \"inc\" points\nvoid Player::IncreaseScore(const unsigned short &inc) noexcept {\n\tscore += inc;\n}\n\n// resets the score and the ability to castle to their initial values\nvoid Player::Reset() noexcept {\n\tscore = 0;\n\tcastling = true;\n}\n\n// operator overload for '=='\nbool Player::operator== (const Player &p) const noexcept {\n\treturn !name.compare(p.name);\n}\n\n\n\n\n\n\n// creates a subtree which contains all possible moves the player can make\nvoid PathNode::CreateSubtree(Chess &c) noexcept {\n\tauto all_moves = c.AllMoves();\t\t\t\t\t// add all possible moves to the Node's map\n\tfor(auto &move : all_moves) {\n\t\tChess::ChangeToRealCoordinates(move[0], move[1], move[2], move[3]);\n\t\tchild_node_list.emplace(move, PathNode());\n\t}\n}\n\n// returns the maximum score for the minimizing player and the minimum score for the maximizing player in each recursion\nfloat PathNode::AlphaBeta(Chess &c, unsigned short &depth, float alpha, float beta, const bool &maximizing_player, const bool &initial_turn) noexcept {\n\tif(!depth)\n\t\treturn c.EvaluateBoard(initial_turn);\n\tCreateSubtree(c);\n\tfloat points = maximizing_player ? -9999 : 9999;\n\tfor(auto &node : child_node_list) {\t\t\t\t\t\t// 1-0: from, 3-2: to\n\t\tif(c.GetPiece(node.first[2], node.first[3]) == W_KING - 7*c.GetTurn()) {\n\t\t\tchild_node_list.clear();\n\t\t\treturn maximizing_player ? 9999 : -9999;\t\t// if my target piece is king, then it is the most rewarding move\n\t\t}\n\t\tc.MovePiece(node.first[0], node.first[1], node.first[2], node.first[3], false, false);\n\t\tpoints = maximizing_player ? std::max(points, node.second.AlphaBeta(c, --depth, alpha, beta, false, initial_turn))\t\t// recursive alpha-beta algorithm\n\t\t: std::min(points, node.second.AlphaBeta(c, --depth, alpha, beta, true, initial_turn));\n\t\tmaximizing_player ? alpha = std::max(alpha, points) : beta = std::min(beta, points);\n\t\t++depth;\n\t\tc.MovePieceBack(node.first[0], node.first[1], node.first[2], node.first[3]);\n\t\tif(alpha >= beta)\n\t\t\tbreak;\n\t}\n\tchild_node_list.clear();\n\treturn points;\n}\n\n// the main function which returns the optimal move calculated by the alpha-beta algorithm\nstd::string PathNode::AlphaBetaRoot(Chess &c, unsigned short &difficulty) noexcept {\n\tCreateSubtree(c);\n\tstd::vector<std::string> ideal_moves;\n\tfloat max_move_score = -9999;\n\tfor(auto &node : child_node_list) {\n\t\tif(c.GetPiece(node.first[2], node.first[3]) == W_KING - 7*c.GetTurn()) {\n\t\t\tchild_node_list.clear();\n\t\t\treturn node.first;\t\t\t\t\t\t// if my target piece is king, then this move is a game winner so return this move\n\t\t}\n\t\tc.MovePiece(node.first[0], node.first[1], node.first[2], node.first[3], false, false);\n\t\tfloat move_score = node.second.AlphaBeta(c, difficulty, -10000, 10000, false, !c.GetTurn());\n\t\tif(move_score > max_move_score) {\n\t\t\tmax_move_score = move_score;\n\t\t\tideal_moves.clear();\n\t\t\tideal_moves.emplace_back(node.first);\t// add the most rewarding move to the list\n\t\t}\n\t\telse if(move_score == max_move_score)\n\t\t\tideal_moves.emplace_back(node.first);\n\t\tc.MovePieceBack(node.first[0], node.first[1], node.first[2], node.first[3]);\n\t}\n\tchild_node_list.clear();\t\t\t\t\t\t// delete the whole tree\n\tauto move = ideal_moves.cbegin();\n\tadvance(move, GetRandomNumber<unsigned short>(0, ideal_moves.size()-1));\n\treturn *move;\n}\n\n\n\nint main(){\n\n    \n    std::string s1,s2;\n   \n    int i = 0;\n\tChess c(\"0\", 3, \"1\", 3);\n\t\n    std::cin >> s1 >> s2;\n\tif(s1 == \"-1\"){\n\t\twhile(c.BotsTurn(s1,s2)){\n\t\t\tstd::cout << s1 <<\" \" << s2<<std::endl;\n\t\t\tstd::cin >> s1 >> s2;  \n\t\t\n\t\t\tc.PlayersTurn(s1,s2);\n\t\t\t\n\t\t\n\t\t};\n\t}else{\n\t\twhile(c.PlayersTurn(s1,s2)){\n\t\t\t\n\t\t\tc.BotsTurn(s1,s2);\n\t\t\t\n\t\t\tstd::cout << s1 <<\" \" << s2<<std::endl;\n\t\t\tstd::cin >> s1 >> s2;  \n\t\t};\n\t}\n    \n    \n    return 0;\n}";
    private readonly string placeholder0 = "placeholder 0";
    private readonly string placeholder1 = "placeholder 1 xd";
    private readonly string placeholder2 = "placeholder 2 xdd";

    private readonly string zero_for_2_players_py =
        "import random\n\nclass Card:\n    def __init__(self, suit, value):\n        self.suit = suit\n        self.value = value\n\n    def __repr__(self):\n        return f\"{self.value} of {self.suit}\"\n    \n    def __str__(self):\n        return f\"{self.value} of {self.suit}\"\n\nclass Deck:\n    def __init__(self):\n        self.cards = []\n        self.build()\n\n    def build(self):\n        suits = ['Yellow', 'Green', 'Blue', 'Red', 'Pink', 'White', 'Brown']\n        values = ['1', '2', '3', '4', '5', '6', '7', '8']\n        for suit in suits:\n            for value in values:\n                self.cards.append(Card(suit, value))\n\n    def shuffle(self):\n        random.shuffle(self.cards)\n\n    def draw(self):\n        if len(self.cards) > 0:\n            return self.cards.pop()\n        else:\n            return None\n\n    def __len__(self):\n        return len(self.cards)\n\n    def __repr__(self):\n        return f\"Deck with {len(self)} cards\"\n\ndef count_points(hand):\n    if (len(hand) != 9):\n        raise ValueError(\"Wrong number of cards in hand!\")\n    points = 0\n    distinct_values = set()\n    distinct_colors = set()\n    color_counts = {}\n    value_counts = {}\n\n    for card in hand:\n        distinct_values.add(card.value)\n        distinct_colors.add(card.suit)\n        color_counts[card.suit] = color_counts.get(card.suit, 0) + 1\n        value_counts[card.value] = value_counts.get(card.value, 0) + 1\n        \n    for card in hand:\n        if (color_counts[card.suit] == 5 and value_counts[card.value] == 5):\n            return 0\n\n    for color in distinct_colors:\n        if color_counts[color] > 4:\n            distinct_values = set()\n            value_counts = {}\n            for card in hand:\n                if (card.suit != color):\n                    distinct_values.add(card.value)\n                    value_counts[card.value] = value_counts.get(card.value, 0) + 1\n            \n    for value in distinct_values:\n        if value_counts[value] < 5:\n            points += int(value)\n\n    return points\n\ndef deal_cards(deck, num_players, num_cards):\n    players_hands = [[] for _ in range(num_players)]\n    for _ in range(num_cards):\n        for i in range(num_players):\n            card = deck.draw()\n            if card:\n                players_hands[i].append(card)\n    return players_hands\n\ndef exchange_card(player_hand, table_cards, hand_index, table_index):\n    if hand_index < 0 or hand_index >= len(player_hand):\n        print(\"Wrong card index.\")\n        return\n    if table_index < 0 or table_index >= len(table_cards):\n        print(\"Wrong table index.\")\n        return\n    player_hand[hand_index], table_cards[table_index] = table_cards[table_index], player_hand[hand_index]\n    \ndef give_bot_info(player, last):\n    global hands\n    global table_cards\n    response = \"\"\n    hand = hands[player]\n    for card in hand:\n        response += str(card)\n        response += \";\"\n    response += \" Table: \"\n    for card in table_cards:\n        response += str(card)\n        response += \";\"\n    #if(last):\n    #    response += \"last\"\n    print(response)\n    \ndef select_winner(hands):\n    index = 0\n    mini = 50\n    for i in range(len(hands)):\n        if(count_points(hands[i]) < mini):\n            index = i\n            mini = count_points(hands[i])\n    print(index)\n    \n\ndef set_game(players = 4, cards = 9):\n    global deck\n    deck = Deck()\n    deck.shuffle()\n    \n    global num_players\n    global num_cards_per_player\n    num_players = players          # valid 2-5 (for currend set of cards)\n    num_cards_per_player = cards   # shouldnt be changed, unless with other mechanics\n    \n    global hands\n    global table_cards\n    hands = deal_cards(deck, num_players, num_cards_per_player)\n    table_cards = [deck.draw() for _ in range(5)]\n\ndef game(players = 2, cards = 9):\n    set_game(players, cards)\n    folds = 0\n    zero = False\n    last = False\n    iteration = 0\n    while(folds < 2 and iteration < 1000):\n        iteration += 1\n        for player in range(players):\n            print(player)\n            if (folds > 1):\n                last = True\n            give_bot_info(player, last)\n            response = input()\n            if(response.lower() == 'fold'):\n                folds += 1\n            else:\n                exchange_card(hands[player], table_cards, int(response[0]), int(response[2]))\n                if(count_points(hands[player]) == 0):\n                    zero = True\n                    break\n        if(zero):\n            break\n    print(-1)\n    select_winner(hands)\n    \ndef check_winner():\n    global hands\n    global num_players\n    \n    for hand in hands:\n        print(count_points(hand))\n        \ngame()\n\n# check_winner()  # debug to print players points";

    public Seeder(GathererService gathererService)
    {
        _gatherer = gathererService;
    }

    private async Task AddFile(string file, string name, long id)
    {
        var uploaded = await _gatherer.GetFile(id);
        if (uploaded.Success) return;
        var byteArray = Encoding.UTF8.GetBytes(file);
        using (var stream = new MemoryStream(byteArray))
        {
            IFormFile formFile = new FormFile(stream, 0, byteArray.Length, "name", "filename.txt");
            var res = await _gatherer.SaveFile(formFile);
            if (res.Success)
            {
                var cont = res.Data.ToString();
                long botFileId = Convert.ToInt32(cont);
                Console.WriteLine($"File {name} added with id {botFileId}");
            }
            else
            {
                Console.WriteLine($"Uploading to FileGatherer failed {res.Message}");
            }
        }
    }

    public async Task Seed()
    {
        await AddFile(placeholder0, "placeholder0.xd", 1);
        await AddFile(bot1Bj_cpp, "bot1BJ.cpp", 2);
        await AddFile(bot2Bj_cpp, "bot2BJ.cpp", 3);
        await AddFile(bot3Bj_cpp, "bot3BJ.cpp", 4);
        await AddFile(black_jack_cpp, "BlackJack.cpp", 5);
        await AddFile(placeholder1, "placeholder0.xd", 6);
        await AddFile(placeholder2, "placeholder0.xd", 7);
        await AddFile(javabot, "bot_zero_5.java", 8);
        await AddFile(bot_zero_py, "bot_zero.py", 9);
        await AddFile(bot_zero_2_py, "bot_zero_2.py", 10);
        await AddFile(bot_zero_3_py, "bot_zero_3.py", 11);
        await AddFile(zero_for_2_players_py, "zero_for_2_players.py", 12);
        await AddFile(chess_game_cpp, "chess_game.cpp", 13);
        await AddFile(chess_bot1_cpp, "chess_bot1.cpp", 14);
        await AddFile(chess_bot2_cpp, "chess_bot2.cpp", 15);
        await AddFile(chess_bot3_cpp, "chess_bot3.cpp", 16);
    }
}